<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CADisplayLink 回顾总结]]></title>
    <url>%2F2018%2F05%2F18%2FiOS-RunLoop-Apply-CADisplayLink%2F</url>
    <content type="text"><![CDATA[概念CADisplayLink 是一个保持和屏幕刷新率同步的定时器。之所以说是同步的而不是一样的，是因为 CADisplayLink 可以设置每几帧回调一次。 原理CADisplayLink 添加到 RunLoop 后，在每次 vsync 信号到来时，都会执行回调。vsync 信号是读取下一帧数据的时钟信号。由于没有源码，不知道确切的设计。但是从 CADisplayLink 的特性来猜想，CADisplayLink 可能是向 RunLoop 注册了某个 source1，在 source1 关联的 port 监听到屏幕刷新结束的时候，就回调，然后在 CADisplayLink 内部根据属性设定来决定是否需要对外回调。 与其他两种定时器的比较CADisplayLink 优点： 与屏幕刷新率保持同步。 触发回调的时机相比其他定时器来说，要准确的多。 缺点： 不能被继承。 回调处理时间如果太长，会造成掉帧现象。 回调时间灵活度小，间隔时间只能是屏幕刷新间隔的整数倍。 NSTimer 优点： 回调时间灵活度大，可以随意设定时间。 缺点： 子线程中使用，需要开启 RunLoop，否则，无效。 一般需要注册到 RunLoop 的 commonMode 中使用，否则在视图滑动的时候，不会接受到定时器到时的回调。 回调时机准确度低，有延时。 dispatch_source_t 优点： 不受 runLoop mode 的影响，在视图滑动的时候也可以接受到回调。 缺点： 回调时机较准确，但是不是最准确。 在 GCD 内部管理的线程占满时，回调会阻塞延迟。 引用 CADisplayLink(逐帧动画) 老司机带你走进Core Animation 之CADisplayLink 深入理解CADisplayLink、NSTimer和dispatch_source]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
        <tag>CADisplayLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoreleasePool 回顾总结]]></title>
    <url>%2F2018%2F05%2F15%2FRunLoop-AutoreleasePool%2F</url>
    <content type="text"><![CDATA[概念AutoreleasePool 是 OC 中的一种内存延迟释放机制。正常情况下变量在其作用域结束便被释放，如果使用 autoreleasePool 包裹，则会延迟释放。除非手动干预 autoreleasePool 的释放，否则将在 runLoop 的休眠和退出的时机释放。 整体设计App 在启动后向主线程注册了两个Observer，监听 RunLoop 的 Entry/BeforeWaiting/Exit 三个时机。 Observer1: 负责监听 entry 状态，创建 autoreleasePool(poolPush)，在32位上优先级是-(2^32-1)，最高优先级，保证后续所有操作都在这个 pool 中。 Observer2: 负责监听 beforeWaiting 和 exit 两个状态。优先级是 (2^32-1)，最低优先级，保证在所有操作之后，与 observer1 对应。 beforeWaiting: 先销毁 autoreleasePool(poolPop)，释放 pool 中之前延迟释放的对象；然后再创建 autoreleasePool(poolPush)，为 afterWaiting 的操作做准备。 exit: 销毁 autoreleasePool(poolPop)，释放 pool 中之前延迟释放的对象。 AutoReleasePool 是一个隐式的双向链表，每一个节点都是一个 autoreleasePoolPage(可见数据结构)，也就是一个内存页，大小为4k。 每一个线程都一个 autoreleasePool 栈，来管理与其关联的 autoreleasePool，当线程销毁时，所有相关联的 pool 都被销毁，并释放其中的对象。 代码分析 自动释放池是用双向链表来实现的，充分利用内存页，能快速查询且 release 延时释放的对象。 以哨兵对象作为一次 push 进来的标志，便于 pop 的时候查找，哨兵对象实际就是一个 nil。 调用 autorelease 的时候，会将对象压入 autoreleasePoolPage 中。 pop 的时候会找到就近的哨兵对象，然后依次 release 对象，直到这个哨兵对象。 嵌套 autoreleasePool 的 pop，也是一层一层的找哨兵对象，然后释放对象。 iOS 的入口函数中表明整个 APP 的运行行为都是放在一个 autoreleasePool 的。 每个线程都有 autoreleasePool，且1对1。 主线程的 autoreleasePool 是默认开启的。因为 RunLoop 是默认运行的，APP 在观察到 KCFRunLoopEntry 的时候就创建了 pool。 子线程的 runLoop 默认是不开启的。它的 pool 是在第一次调用 autorelease 的时候创建的。 @autoreleasePool 语法糖的背后实现其实是一个局部 autoreleasePool 变量的生命周期。 12345678910111213141516- (void)func &#123; @autoreleasepool &#123; // do something. &#125;&#125;==&gt;- (void)func &#123; __AtAutoreleasePool __autoreleasepool; // 当 __autoreleasepool 析构的时候，自动释放池 pop // do something.&#125;因为：struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 核心代码Push 操作NSObject.mm line:1881123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// push 函数void *objc_autoreleasePoolPush(void)&#123; // 调用 AutoreleasePoolPage 的 push return AutoreleasePoolPage::push(); &#125;# define POOL_BOUNDARY nil // 每次 push 的起始标记，也叫哨兵// AutoreleasePoolPage 的 push 函数，以简化掉 debug 的兼容代码static inline void *push()&#123; // 将 POOL_BOUNDARY 压入 autoreleasePoolPage 中，作为这次 autoreleasePool 的一个标记 id *dest = autoreleaseFast(POOL_BOUNDARY); assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125;// 快速将对象压入 page 的函数 static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); // 获取当前可用的 page if (page &amp;&amp; !page-&gt;full()) &#123; // page 未满的时候，压入对象 return page-&gt;add(obj); // 压入对象 &#125; else if (page) &#123; // page 已满，需要创建新的 page，并压入对象 return autoreleaseFullPage(obj, page); &#125; else &#123; // 当前没有 page，是一个空链表 return autoreleaseNoPage(obj); &#125;&#125;// page 要溢出时的处理函数static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)&#123; assert(page == hotPage()); // 断言一定是当前可用的 page assert(page-&gt;full()); // 断言 page 一定满了 do &#123; if (page-&gt;child) page = page-&gt;child; // 使用下一个 page else page = new AutoreleasePoolPage(page); // 创建新 page，并加入到链表中 &#125; while (page-&gt;full()); // 只有 page 满的情况才执行 setHotPage(page); // 重新设定当前可用 page，并存储在 TLS 中 return page-&gt;add(obj); // 把目标对象压入 page&#125;// 空链表的时候处理的函数static __attribute__((noinline)) id *autoreleaseNoPage(id obj)&#123; assert(!hotPage()); // 断言当前没有可用的 page bool pushExtraBoundary = false; // 是否添加哨兵的标志位 if (haveEmptyPoolPlaceholder()) &#123; // 有占位的 page pushExtraBoundary = true; // 需要添加哨兵 &#125; else if (obj != POOL_BOUNDARY) &#123; // 目标对象不是哨兵 // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, pthread_self(), (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; else if (obj == POOL_BOUNDARY) &#123; // 目标对象是哨兵 return setEmptyPoolPlaceholder(); // 添加一个占位的 page &#125; 创建链表中的第一个节点 page AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // 设置当前可用的 page if (pushExtraBoundary) &#123; page-&gt;add(POOL_BOUNDARY); // 添加哨兵 &#125; // Push the requested object or pool. return page-&gt;add(obj); // page 压入对象&#125; Pop 操作NSObject.mm line:188612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// pop 函数void objc_autoreleasePoolPop(void *ctxt)&#123; // 调用 AutoreleasePoolPage 的 pop AutoreleasePoolPage::pop(ctxt);&#125;// AutoreleasePoolPage 的 pop 函数，token 为 push 函数的返回值static inline void pop(void *token)&#123; AutoreleasePoolPage *page; id *stop; // token 是占位 page if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // 当前有可用的 page pop(coldPage()-&gt;begin()); // 从第一个不可用的 page 的第一个压入的对象开始递归 &#125; else &#123; // 当前 page 为空，说明 pool 没有被使用 setHotPage(nil); // 设置当前 page 为空 &#125; return; &#125; page = pageForPointer(token); // 查找 token 所在的 page stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; // token 不是哨兵 // 一些错误的处理 if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); // 重新计算最高水位 page-&gt;releaseUntil(stop); // 释放对象知道遇到 token，也就是哨兵 if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; Objc autorelease 操作NSObject.mm line:23311234567891011121314151617181920212223242526272829// autorelease 外部可用 API- (id)autorelease &#123; return ((id)self)-&gt;rootAutorelease(); // 调用 objc_object 的 autorelease 方法&#125;// objc_object 的 autorelease 函数inline id objc_object::rootAutorelease()&#123; // 被 TaggedPointer 标记，优化内存占用，指针值不是地址，而是值 if (isTaggedPointer()) return (id)this; // TLS + __builtin_return_address 内存优化 if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this; return rootAutorelease2(); // 继续调用另一个 autorelease 的函数&#125;// autorelease2 函数__attribute__((noinline,used)) id objc_object::rootAutorelease2()&#123; assert(!isTaggedPointer()); return AutoreleasePoolPage::autorelease((id)this); // 开始调用 autoreleasePoolPage 的 autorelease 函数，此处开始进入到 autoreleasePool 了。&#125;// autoreleasePoolPage 的 autorelease 函数static inline id autorelease(id obj)&#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 插入到 autoreleasePoolPage assert(!dest || dest == EMPTY_POOL_PLACEHOLDER || *dest == obj); return obj;&#125; 辅助函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# define EMPTY_POOL_PLACEHOLDER ((id*)1) // 只是一个占位的 page// 获取当前可用的 pagestatic inline AutoreleasePoolPage *hotPage()&#123; AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key); // TLS 中查找保存的 page // 遇到占位 page，则无可用 page if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil; if (result) result-&gt;fastcheck(); // 对 page 结构的完整性做校验 return result;&#125;// 设置当前可用的 pagestatic inline void setHotPage(AutoreleasePoolPage *page)&#123; if (page) page-&gt;fastcheck(); // page 完整性校验 tls_set_direct(key, (void *)page); // TLS 存储&#125;// 构造函数AutoreleasePoolPage(AutoreleasePoolPage *newParent): magic(), next(begin()), thread(pthread_self()),parent(newParent), child(nil),depth(parent ? 1+parent-&gt;depth : 0),hiwat(parent ? parent-&gt;hiwat : 0)&#123; if (parent) &#123; parent-&gt;check(); assert(!parent-&gt;child); parent-&gt;unprotect(); parent-&gt;child = this; // 将新的节点加入到链表中 parent-&gt;protect(); &#125; protect();&#125;// 判断是否有空的占位的 pagestatic inline bool haveEmptyPoolPlaceholder()&#123; id *tls = (id *)tls_get_direct(key); return (tls == EMPTY_POOL_PLACEHOLDER);&#125;// 添加占位的 pagestatic inline id* setEmptyPoolPlaceholder()&#123; assert(tls_get_direct(key) == nil); tls_set_direct(key, (void *)EMPTY_POOL_PLACEHOLDER); return EMPTY_POOL_PLACEHOLDER;&#125;// 链表中第一个不可用的 pagestatic inline AutoreleasePoolPage *coldPage()&#123; AutoreleasePoolPage *result = hotPage(); // 获取当前 page if (result) &#123; while (result-&gt;parent) &#123; // 一直反向遍历 result = result-&gt;parent; result-&gt;fastcheck(); &#125; &#125; return result;&#125;// 释放函数void releaseUntil(id *stop)&#123; // Not recursive: we don&apos;t want to blow out the stack // if a thread accumulates a stupendous amount of garbage // 清理到哨兵 while (this-&gt;next != stop) &#123; AutoreleasePoolPage *page = hotPage(); // 当前 page while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); // 安全策略，重置当前 page &#125; page-&gt;unprotect(); // 允许 write 操作 id obj = *--page-&gt;next; // 找到 next 之前的对象，next 指向的是下一个可用的空地址 memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); // 内存清理 page-&gt;protect(); // 关闭 write 操作 if (obj != POOL_BOUNDARY) &#123; // 非哨兵 objc_release(obj); // 想对象发送 release 消息 &#125; &#125; setHotPage(this); // 重置当前 page&#125; 关联知识 Tagged Pointer Tagged Pointer 是用来存储一些轻量级的对象，来优化内存管理。比如 NSNumber 等。 Tagged Pointer 的指针不再是地址了，而是真正的值。不存储在堆上。 内存读取有3倍效率，创建是以前的106倍。 引用 源码 AutoreleasePool的原理和实现 黑幕背后的Autorelease Objective-C Autorelease Pool 的实现原理 iOS开发笔记（七）：深入理解 Autorelease Objective-C Target Point]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>autorelease</tag>
        <tag>autoreleasePool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop回顾总结]]></title>
    <url>%2F2018%2F05%2F08%2FRunLoopReviewSummary%2F</url>
    <content type="text"><![CDATA[概念一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。 1234567function eventLoop() &#123; initialize(); // 内部初始化 do&#123; let msg = getNextMsg(); // 获取下一个消息/事件 processMsg(msg); // 执行消息/事件 &#125; while (msg != quit); // 循环知道退出消息到达&#125; RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。 应用 框架图 代码分析Loop - Thread Relation Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。 主线程的 RunLoop 是默认创建的，其他线程的 RunLoop 是用时创建，懒加载的。 线程的 RunLoop 并不是每次都是从全局字典中获取的，而是从全局或者 TLS 中获取。这样可以加快获取的过程，有利于性能的提升。 主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。 其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。 CFRunLoop 中使用了锁来保证线程安全。NSRunLoop 是基于 CFRunLoop 封装的，没有设计线程安全。 流程图 核心代码CFRunLoop.c line:135312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static pthread_t kNilPthreadT = (pthread_t)0; // 初始化 kNilPthreadT 为空线程static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。// 获取 runnLoop 的函数。CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; // 入参线程为空，则默认使用主线程。 __CFLock(&amp;loopsLock); // 操作 loops 前加锁。 if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。 __CFUnlock(&amp;loopsLock); // 解锁。 CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。 CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。 // 将 dict 赋值给 loops，内部有锁。 if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); // 释放临时变量dict。 &#125; CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。 __CFLock(&amp;loopsLock); // 加锁。 &#125; CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop __CFUnlock(&amp;loopsLock); // 解锁。 // loops 中没有线程 t 的 loop if (!loop) &#123; CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。 __CFLock(&amp;loopsLock); // 解锁。 loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。 // 二次校验 loops 中有没有线程 t 的 loop。 if (!loop) &#123; CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。 loop = newLoop; // 赋值给 loop。 &#125; // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFUnlock(&amp;loopsLock); // 解锁。 CFRelease(newLoop); // 释放 newLoop。 &#125; if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程 _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。 if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123; _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。 &#125; &#125; return loop; // 返回线程 t 的 loop。&#125;// 获取主线程的 mainLoop 函数CFRunLoopRef CFRunLoopGetMain(void) &#123; CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。 // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。 static CFRunLoopRef __main = NULL; // no retain needed // 不存在，则获取主线程的 mainLoop。 if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return __main;&#125;// 获取当前线程的 loop 函数CFRunLoopRef CFRunLoopGetCurrent(void) &#123; CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。 // TLS 中获取当前线程的 loop。 CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; // 不存在，则获取当前线程的 loop。 return _CFRunLoopGet0(pthread_self());&#125; 辅助代码TLS 操作函数CFPlatform.c line: 6481234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 存储函数CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123; if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错 _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot); HALT; &#125; // 获取 TSL 中的 table __CFTSDTable *table = __CFTSDGetTable(); if (!table) &#123; // table 不存在，报错 // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore. _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot); return NULL; &#125; void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值 table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值 table-&gt;destructors[slot] = destructor; // 存储析构器 return oldVal; // 返回数据变更之前的值&#125;// 读取函数CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123; if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错 _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot); HALT; &#125; // 获取 TSL 中的 table __CFTSDTable *table = __CFTSDGetTable(); if (!table) &#123; // table 不存在，则报错 // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore. _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot); return NULL; &#125; uintptr_t *slots = (uintptr_t *)(table-&gt;data); return (void *)slots[slot]; // 按 key 从 data 中获取值并返回&#125;// 获取 TLS 的 tablestatic __CFTSDTable *__CFTSDGetTable() &#123; // 获取 TLS 的 table __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific(); // Make sure we&apos;re not setting data again after destruction. if (table == CF_TSD_BAD_PTR) &#123; // 被析构了 return NULL; &#125; // Create table on demand if (!table) &#123; // This memory is freed in the finalize function table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间 pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 __CFTSDSetSpecific(table); // 存储 table &#125; return table; //返回 table&#125;// table 获取函数static void *__CFTSDGetSpecific() &#123; return _pthread_getspecific_direct(CF_TSD_KEY);&#125; Loop Run RunLoop 实质上是一个 do…While 的循环，通过 port trap 消息来执行。 RunLoop 有五种运行 mode，每个 mode 中有多个 modeItem。 kCFRunLoopDefaultMode: 默认运行 mode。 UITrackingRunLoopMode: 界面追踪 mode，用户追踪 scrollView 的滑动。 UIInitializationRunLoopMode: 启动初始化 mode，只在该 mode 下运行一次。 GSEventReceiveRunLoopMode：系统内部事件的 mode。 kCFRunLoopCommonModes：一个集合，集合其他 mode。 ModeItem: Source/Timer/Observer 的统称，没有实际的数据结构。 CommonModes: 标记为 common 的 mode，这些 mode 的 modeItem 是相同的。可以使得 RunLoop 可以看似在多个 mode 下共同运行。 CommonModeItems: common mode 下运行的事件集合。 事件类型： Timer: 与 NSTimer 是 Toll-Free Bridging 的，基于时间的触发源。多个 Timer 对应一个modeQueuePort。 Source0: 只有 block，没有 port，用户级事件。多个 source0 对应一个 wakeupPort，当 source0 被标记后，会通过 wakeupPort 唤醒执行。 Source1: 有 blok 和 port，系统级事件。 Observer: 对 loop 过程的一个监听。 KCFRunLoopEntry: loop 进入。 KCFRunLoopBeforeTimers: 开始处理Timers。 KCFRunLoopBeforeSources: 开始处理Source。 KCFRunLoopBeforeWaiting: 开始休眠。 KCFRunLoopAfterWaiting: 结束休眠。 KCFRunLoopExit: loop 退出。 RunLoop 在处理完 source0 后多空转一次，是为了保证source0被确切的执行完毕。 RunLoop 只能在单一 Mode 下运行，切换 mode 后吧，新 mode 下运行结束后，并不会继续之前的 mode 下重新 run，但是会还原之前的运行数据。 RunLoop 的 block 是用单向链表存储的，在第一次运行完 block 的时候会变更为环形链表，便于后续 block 执行的查找。block 猜测是 dispatch 过来的。 perform…selector 最后对应的是一个定时器事件。 流程图 核心代码CFRunLoop.c line:2649123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267// mode 切换函数 SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ CHECK_FOR_FORK(); // 进程检查 // 检查loop是否被析构 if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; __CFRunLoopLock(rl); // 加锁 CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 查找对应 modeName 的 mode 且对 mode 加锁 // 判断 mode 是否有效 if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; Boolean did = false; if (currentMode) __CFRunLoopModeUnlock(currentMode); // mode 解锁 __CFRunLoopUnlock(rl); // loop 解锁 return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished; // 返回运行结果 &#125; volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); // 记录当前 mode 的运行数据，并将当前数据置位，准备给新的 mode 使用 CFRunLoopModeRef previousMode = rl-&gt;_currentMode; // 记录当前 mode rl-&gt;_currentMode = currentMode; // 变更 loop 的 mode 为目标 mode int32_t result = kCFRunLoopRunFinished; // 初始化一个运行结果 if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 发出 entry 通知 result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 执行 run 函数 if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); // 发出 exit 通知 __CFRunLoopModeUnlock(currentMode); // mode 解锁 __CFRunLoopPopPerRunData(rl, previousPerRun); // 将记录的之前的 mode 的运行数据还原 rl-&gt;_currentMode = previousMode; // 将记录的之前的 mode 还原 __CFRunLoopUnlock(rl); // loop 解锁 return result; // 返回目标 mode 的运行结果&#125;// Run 函数，已经把架构指令集适配代码简化掉了static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123; uint64_t startTSR = mach_absolute_time(); // 获取机器时间 if (__CFRunLoopIsStopped(rl)) &#123; // 判断 loop 是够已经停止 __CFRunLoopUnsetStopped(rl); // 置位状态 return kCFRunLoopRunStopped; // 返回状态 &#125; else if (rlm-&gt;_stopped) &#123; // 对应的 mode 是否已经停止 rlm-&gt;_stopped = false; // 置位状态 return kCFRunLoopRunStopped; // 返回状态 &#125; mach_port_name_t dispatchPort = MACH_PORT_NULL; // 给dispatch 初始化一个空端口 Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); // 判断是否第一次配发到主线程 if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); // 在主线程下，会给 dispatch 配置一个 port mach_port_name_t modeQueuePort = MACH_PORT_NULL; // 给 modeQueue 初始化一个空 port，查看全文代码，queue 里面只是存储了 timer if (rlm-&gt;_queue) &#123; // queue 存在 modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue); // 配置一个 port if (!modeQueuePort) &#123; // 配置 port 失败，报错 CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1); &#125; &#125; dispatch_source_t timeout_timer = NULL; // 初始化一个空timer，用来做 loop 超时监测的 struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); // 超时上下文内存初始化 if (seconds &lt;= 0.0) &#123; // instant timeout seconds = 0.0; timeout_context-&gt;termTSR = 0ULL; // 超时时间为0 &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; // 判断是够在限制时间间隔之内 dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); // 根据线程分配队列 timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 创建定时器 dispatch_retain(timeout_timer); // 增加引用计数 // 配置上下文 timeout_context-&gt;ds = timeout_timer; // 设置 timer timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); // 设置 loop timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); // 设置时间 // 设置上下文 dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context // 设置超时操作 dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout); // 设置取消操作 dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel); uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL); // 设置超时定时器 dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL); // 启动定时器 dispatch_resume(timeout_timer); &#125; else &#123; // infinite timeout seconds = 9999999999.0; timeout_context-&gt;termTSR = UINT64_MAX; // 设置最大超时时间 &#125; Boolean didDispatchPortLastTime = true; // 初始化 dispatch port 的标记 int32_t retVal = 0; // 运行结果初始化 // 进入主体事件循环 do &#123; voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED; voucher_t voucherCopy = NULL; uint8_t msg_buffer[3 * 1024]; // 初始化一个 msg 的缓冲 mach_msg_header_t *msg = NULL; // msg mach_port_t livePort = MACH_PORT_NULL; // 当前活动的 port，初始化为 null __CFPortSet waitSet = rlm-&gt;_portSet; // 待监听的 port 的集合 __CFRunLoopUnsetIgnoreWakeUps(rl); // 设置可唤醒状态 if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知要处理 timers if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理要处理 sources, 这里是 source0 __CFRunLoopDoBlocks(rl, rlm); // 执行 block，从代码上猜测应该是 dispatch 塞进的 block，使用双向链表保存 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); // 执行可以执行的 source0 if (sourceHandledThisLoop) &#123; __CFRunLoopDoBlocks(rl, rlm); // 执行block &#125; Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); // source 被执行完 或者 loop 超时，需要再空转一圈，来保证 source0 被彻底执行完，因为 source0 不具备主动唤醒能力，只能被动执行 // 第一次不会执行 if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; // 是否是 dispatch 的 port msg = (mach_msg_header_t *)msg_buffer; // 缓冲中取 msg // 监听 port 中消息 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; // 跳转到消息执行体 &#125; &#125; didDispatchPortLastTime = false; // 置位 // 通知即将要休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); __CFRunLoopSetSleeping(rl); // 设置 sleep 状态 // do not do any user callouts after this point (after notifying of sleeping) // Must push the local-to-this-activation ports in on every loop // iteration, as this mode could be run re-entrantly and we don&apos;t // want these ports to get serviced. __CFPortSetInsert(dispatchPort, waitSet); // 收敛所有的 port __CFRunLoopModeUnlock(rlm); // 解锁 mode __CFRunLoopUnlock(rl); // 解锁 loop CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent(); // 记录休眠开始时间点 // 进入内部监听循环体，只要跳出该循环体，则代表 loop 被唤醒 do &#123; if (kCFUseCollectableAllocator) &#123; // objc_clear_stack(0); // &lt;rdar://problem/16393959&gt; memset(msg_buffer, 0, sizeof(msg_buffer)); // 清空缓冲区 &#125; msg = (mach_msg_header_t *)msg_buffer; __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); // 监听 port 集合 // 是否为 modeQueuePort，用来处理 timers if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer. while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue)); // 遍历 modeQueue，判断是否有 timer 到时了 // 到时，则置位，且跳出内部循环体 if (rlm-&gt;_timerFired) &#123; // Leave livePort as the queue port, and service timers below rlm-&gt;_timerFired = false; // 置位 break; &#125; else &#123; // 继续读取 msg if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg); &#125; &#125; else &#123; // 非 modeQueuePort 的 port msg 被捕获，则跳出内部循环体 // Go ahead and leave the inner loop. break; &#125; &#125; while (1); __CFRunLoopLock(rl); // 加锁 loop __CFRunLoopModeLock(rlm); // 加锁 mode rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart)); // 记录自己的休眠时间 // Must remove the local-to-this-activation ports in on every loop // iteration, as this mode could be run re-entrantly and we don&apos;t // want these ports to get serviced. Also, we don&apos;t want them left // in there if this function returns. __CFPortSetRemove(dispatchPort, waitSet); // 将 dispatchPort 从监听集合中移除 __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，因为已经醒来了 // user callouts now OK again __CFRunLoopUnsetSleeping(rl); // 置位 sleep 标记 // 通知结束休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); // 消息执行体 handle_msg:; __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，对应 handle_msg 之前的设置 if (MACH_PORT_NULL == livePort) &#123; // 是否为空 port CFRUNLOOP_WAKEUP_FOR_NOTHING(); // 标记自己被唤醒的原因是“啥事也没发生”，一种兜底方案吧 // handle nothing &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; // 是否为唤醒 port CFRUNLOOP_WAKEUP_FOR_WAKEUP(); // 被唤醒 port 唤醒 // do nothing on Mac OS &#125; else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; // 是否为 modeQueuePort CFRUNLOOP_WAKEUP_FOR_TIMER(); // 标记为被 Timer 事件唤醒 if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // 根据机器事件执行 timer，但为成功 // Re-arm the next timer, because we apparently fired early __CFArmNextTimerInMode(rlm, rl); // 再次执行 timer &#125; &#125; else if (livePort == dispatchPort) &#123; // 是否为 dispatch 的 port CFRUNLOOP_WAKEUP_FOR_DISPATCH(); // 标记唤醒的原因是 dispatch __CFRunLoopModeUnlock(rlm); // 解锁 mode __CFRunLoopUnlock(rl); // 解锁 loop _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);f __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); __CFRunLoopLock(rl); // 加锁 loop __CFRunLoopModeLock(rlm); // 加锁 mode sourceHandledThisLoop = true; // 标记执行了 source didDispatchPortLastTime = true; // 标记 dispatch 的 port 换新被执行完 &#125; else &#123; CFRUNLOOP_WAKEUP_FOR_SOURCE(); // 标记唤醒的原因是 source // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again. voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release); // Despite the name, this works for windows handles as well CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); // 获取对应 port 的 source1 if (rls) &#123; mach_msg_header_t *reply = NULL; // 执行 source1 sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; if (NULL != reply) &#123; (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); &#125; &#125; // Restore the previous voucher _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release); &#125; if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg); __CFRunLoopDoBlocks(rl, rlm); // 执行 block if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; retVal = kCFRunLoopRunHandledSource; // 处理完事件的运行结果 &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; retVal = kCFRunLoopRunTimedOut; // 超时运行结果 &#125; else if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); // 置位 retVal = kCFRunLoopRunStopped; // 停止的运行结果 &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; // 置位 retVal = kCFRunLoopRunStopped; // 停止的运行结果 &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; // mode 已经被执行完了 retVal = kCFRunLoopRunFinished; // 结束的运行结果 &#125; voucher_mach_msg_revert(voucherState); os_release(voucherCopy); &#125; while (0 == retVal); // 外层循环执行的条件判断 // 释放超时定时器 if (timeout_timer) &#123; dispatch_source_cancel(timeout_timer); dispatch_release(timeout_timer); &#125; else &#123; free(timeout_context); &#125; return retVal;&#125; 辅助代码Loop 运行数据 push/pop 函数CFRunLoop.c line:6601234567891011121314151617// push 函数CF_INLINE volatile _per_run_data *__CFRunLoopPushPerRunData(CFRunLoopRef rl) &#123; volatile _per_run_data *previous = rl-&gt;_perRunData; // 保存之前的运行数据 rl-&gt;_perRunData = (volatile _per_run_data *)CFAllocatorAllocate(kCFAllocatorSystemDefault, sizeof(_per_run_data), 0); // 重新创建一个运行数据 // 对运行数据做初始化置位 rl-&gt;_perRunData-&gt;a = 0x4346524C; rl-&gt;_perRunData-&gt;b = 0x4346524C; // &apos;CFRL&apos; rl-&gt;_perRunData-&gt;stopped = 0x00000000; rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x00000000; return previous; // 返回当前的运行数据&#125;// pop 函数CF_INLINE void __CFRunLoopPopPerRunData(CFRunLoopRef rl, volatile _per_run_data *previous) &#123; if (rl-&gt;_perRunData) // 判断当前的运行数据shi CFAllocatorDeallocate(kCFAllocatorSystemDefault, (void *)rl-&gt;_perRunData // 存在，则销毁 rl-&gt;_perRunData = previous; // 切换运行数据为上一次的运行数据&#125; Observer/Timer/Source 操作函数操作函数基本类似，这里以 observer 的操作为例做代码展开。CFRunLoop.c line:1668123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 执行 Observerstatic void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123; /* DOES CALLOUT */ CHECK_FOR_FORK(); // 进程 fork 校验 CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0; // observer 个数获取 if (cnt &lt; 1) return; // 没有则退出 /* Fire the observers */ STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1); CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef)); // 创建一个 observer 的集合 CFIndex obs_cnt = 0; for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx); if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123; collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo); // 将未被执行的有效的 observer 保存到 observer 的集合中 &#125; &#125; __CFRunLoopModeUnlock(rlm); // mode 解锁 __CFRunLoopUnlock(rl); // loop 解锁 for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123; CFRunLoopObserverRef rlo = collectedObservers[idx]; __CFRunLoopObserverLock(rlo); // observer 加锁 if (__CFIsValid(rlo)) &#123; Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo); __CFRunLoopObserverSetFiring(rlo); // 设置执行状态 __CFRunLoopObserverUnlock(rlo); // observer 解锁 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info); // 执行 observer if (doInvalidate) &#123; CFRunLoopObserverInvalidate(rlo); // 设置失效状态 &#125; __CFRunLoopObserverUnsetFiring(rlo); // 清除执行状态 &#125; else &#123; __CFRunLoopObserverUnlock(rlo); // observer 解锁 &#125; CFRelease(rlo); &#125; __CFRunLoopLock(rl); // loop 加锁 __CFRunLoopModeLock(rlm); // mode 加锁 if (collectedObservers != buffer) free(collectedObservers);&#125;// 添加 observervoid CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123; CHECK_FOR_FORK(); // 进程 fork 校验 CFRunLoopModeRef rlm; if (__CFRunLoopIsDeallocating(rl)) return; // loop 析构的时候退出 if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return; // observer 和 loop 校验 __CFRunLoopLock(rl); // loop 加锁 if (modeName == kCFRunLoopCommonModes) &#123; // common 标记的 mode 的处理 // 获取 common 标记的 mode 的集合 CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL; // 获取 common 标记的 modeItem 的集合 if (NULL == rl-&gt;_commonModeItems) &#123; rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); &#125; // 将 observer 添加到 common 标记的 modeItem 的集合中 CFSetAddValue(rl-&gt;_commonModeItems, rlo); if (NULL != set) &#123; CFTypeRef context[2] = &#123;rl, rlo&#125;; /* add new item to all common-modes */ CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context); CFRelease(set); &#125; &#125; else &#123; rlm = __CFRunLoopFindMode(rl, modeName, true); // 查询 mode // observer 的集合校验，为空则创建 if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123; rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks); &#125; // 查询 observer 是否已经存在，不存在，则添加 if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123; Boolean inserted = false; for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123; CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx); if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123; CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo); inserted = true; break; &#125; &#125; // 不存在，则添加 if (!inserted) &#123; CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo); &#125; rlm-&gt;_observerMask |= rlo-&gt;_activities; __CFRunLoopObserverSchedule(rlo, rl, rlm); // 对 observer 中的记录的 loop count 做变更 &#125; if (NULL != rlm) &#123; __CFRunLoopModeUnlock(rlm); // mode 解锁 &#125; &#125; __CFRunLoopUnlock(rl); // loop 解锁&#125;// 移除 observervoid CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123; CHECK_FOR_FORK(); // 进程 fork 校验 CFRunLoopModeRef rlm; __CFRunLoopLock(rl); // loop 加锁 if (modeName == kCFRunLoopCommonModes) &#123; // 是否为 common 标记的 mode // common 标记的 mode 集合中是否存在目标 observer if (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rlo)) &#123; CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL; CFSetRemoveValue(rl-&gt;_commonModeItems, rlo); // 从 common 标记的 modeItem 的集合中移除目标 observer if (NULL != set) &#123; CFTypeRef context[2] = &#123;rl, rlo&#125;; /* remove new item from all common-modes */ CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (void *)context); CFRelease(set); &#125; &#125; else &#123; &#125; &#125; else &#123; rlm = __CFRunLoopFindMode(rl, modeName, false); // 查询 mode // observer 集合校验 if (NULL != rlm &amp;&amp; NULL != rlm-&gt;_observers) &#123; CFRetain(rlo); CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo); // 查找 observer if (kCFNotFound != idx) &#123; CFArrayRemoveValueAtIndex(rlm-&gt;_observers, idx); __CFRunLoopObserverCancel(rlo, rl, rlm); // 变更 observer 中记录的 loop count &#125; CFRelease(rlo); &#125; if (NULL != rlm) &#123; __CFRunLoopModeUnlock(rlm); // mode 解锁 &#125; &#125; __CFRunLoopUnlock(rl); // loop 解锁&#125; Block 操作函数CFRunLoop.c line:1618123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 执行 block 函数static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked // blocks 链表校验 if (!rl-&gt;_blocks_head) return false; // mode 校验 if (!rlm || !rlm-&gt;_name) return false; Boolean did = false; // 获取链表的表头 struct _block_item *head = rl-&gt;_blocks_head; // 获取链表的表尾 struct _block_item *tail = rl-&gt;_blocks_tail; rl-&gt;_blocks_head = NULL; rl-&gt;_blocks_tail = NULL; CFSetRef commonModes = rl-&gt;_commonModes; CFStringRef curMode = rlm-&gt;_name; __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); struct _block_item *prev = NULL; struct _block_item *item = head; // 从头开始遍历 while (item) &#123; struct _block_item *curr = item; item = item-&gt;_next; Boolean doit = false; // 校验是否执行 if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123; doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode)); &#125; else &#123; doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode)); &#125; // 不执行，则还原 if (!doit) prev = curr; // 执行，则继续向后遍历 if (doit) &#123; // 变更链表的头尾 if (prev) prev-&gt;_next = item; if (curr == head) head = item; if (curr == tail) tail = prev; void (^block)(void) = curr-&gt;_block; CFRelease(curr-&gt;_mode); free(curr); // 执行 block if (doit) &#123; __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); did = true; &#125; Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc &#125; &#125; __CFRunLoopLock(rl); __CFRunLoopModeLock(rlm); // 环形链表变更 if (head) &#123; tail-&gt;_next = rl-&gt;_blocks_head; rl-&gt;_blocks_head = head; if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail; &#125; return did;&#125;// block 存储函数void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123; CHECK_FOR_FORK(); // mode 类型的判断 if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123; mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode); __CFRunLoopLock(rl); // ensure mode exists CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true); // 查询 mode，没有则创建 if (currentMode) __CFRunLoopModeUnlock(currentMode); __CFRunLoopUnlock(rl); &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123; CFIndex cnt = CFArrayGetCount((CFArrayRef)mode); const void **values = (const void **)malloc(sizeof(const void *) * cnt); CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values); mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks); __CFRunLoopLock(rl); // ensure modes exist for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true); if (currentMode) __CFRunLoopModeUnlock(currentMode); &#125; __CFRunLoopUnlock(rl); free(values); &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123; CFIndex cnt = CFSetGetCount((CFSetRef)mode); const void **values = (const void **)malloc(sizeof(const void *) * cnt); CFSetGetValues((CFSetRef)mode, values); mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks); __CFRunLoopLock(rl); // ensure modes exist for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true); if (currentMode) __CFRunLoopModeUnlock(currentMode); &#125; __CFRunLoopUnlock(rl); free(values); &#125; else &#123; mode = NULL; &#125; block = Block_copy(block); // 校验 mode 和 block if (!mode || !block) &#123; if (mode) CFRelease(mode); if (block) Block_release(block); return; &#125; __CFRunLoopLock(rl); // 链表节点创建，表尾添加 struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item)); new_item-&gt;_next = NULL; new_item-&gt;_mode = mode; new_item-&gt;_block = block; if (!rl-&gt;_blocks_tail) &#123; rl-&gt;_blocks_head = new_item; &#125; else &#123; rl-&gt;_blocks_tail-&gt;_next = new_item; &#125; rl-&gt;_blocks_tail = new_item; __CFRunLoopUnlock(rl);&#125; 关联知识Toll-Free Bridging Toll-Free Bridging 是指在多个框架中数据类型可以无缝切换。在 iOS 中是指 CoreFoundation 和 Foundation 两个框架之间数据类型的转换。 不是所有者两个框架中的数据类型都可以相互转换。以下是不能相互转换的 NSRunLoop 和 CFRunLoop NSBundle 和 CFBundle NSDateFormatter 和 CFDateFormatter MRC 下不涉及内存管理的转移，可以直接转换。 ARC 下涉及内存管理的转移，在转换时需要指定内存管理的所有权。 __bridge: 不改变内存管理方式。 CF -&gt; F: F 的内存由编译器管理，CF 的内存管理由开发者管理。 F -&gt; CF: F 的内存由编译器管理，CF 没有被 retain，不需要处理。 bridge_reatained: 解决 bridge 下 F -&gt; CF 时，F 被释放，CF 也就被释放，再使用就会出现内存泄露的问题。 F 的内存有编译器管理，CF 会被编译器 retain，内存需要由开发者管理。 由于 CF 被 retain，再使用就不会出现 __bridge 无法解决的内存泄漏问题了。 bridge_transfer: 解决 bridge 下 CF -&gt; F 时，复杂的中间变量和 CF 的内存管理问题而做的简化处理。 F 的内存由编译器管理 CF 的内存由编译器转移了，开发者不需要再处理。 进程/线程间通信 线程间使用 NSPort 通信 进程间使用 NSTask 通信 线程安全 多个线程在临界区产生竞态条件，即会引起线程安全问题。 多发生在写操作时产生线程安全问题。 容易引起线程安全问题的资源： 共享资源 局部对象引用：对象放在共享堆中，可以被多个线程使用，引用是不被共享的。局部变量不会引起线程安全问题，因为存放在线程的栈中。 文件、数据库 通过加锁来解决线程安全问题。 引用 源码 关于RunLoop部分源码的注释 深入理解RunLoop RunLoop学习笔记 老司机出品——源码解析之RunLoop详解 Check_For_Fork Toll-Free Bridging iOS线程通信和进程通信的例子 iOS-线程安全探究]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客]]></title>
    <url>%2F2018%2F05%2F06%2FopenMyBlog%2F</url>
    <content type="text"><![CDATA[基础环境配置 node.js 安装 git 环境安装 hexo 安装 npm install -g hexo-cli 权限不够请使用 sudo npm install -g hexo-cli GitHub 创建博客关联仓库 在gitHub上创建一个仓库，起名your_github_name.github.io 搭建博客 创建属于你的博客文件夹xxxBlog 并初始化 cd xxxBlog hexo init 导入依赖包 npm install 在上述步骤生成的_config.yml中定制配置 itle: Choose a titlesubtitle: Any subtitle you likedescription: Anything you likeauthor: Your namelanguage: zh-CNtimezone: Asia/Shanghaideploy:type: gitrepo: https://github.com/your_github_name/your_github_name.github.com.gitbranch: master 博客部署 开启本地验证 hexo server 安装部署器 npm install hexo-deployer-git –save 博客部署到GitHub上 hexo deploy 浏览器your_github_name.github.io访问部署以后的博客 博客主题切换 挑选自己喜欢的主题，Google上随便一搜hexo的主题多的是，我自己使用的是Maupassant的主题，屠夫的优化版。 git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 安装主题和渲染器 npm install hexo-renderer-jade –save npm install hexo-renderer-sass –save 重新编辑xxxBlog下的_config.yml文件 将theme的值改为maupassant hexo三部曲 hexo clean hexo g hexo deploy 浏览器your_github_name.github.io访问部署以后的新主题的博客 404页面配置 在source下创建一个404.html的文件 使用腾讯公益404代码，直接在html中写如下代码&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 适配多电脑发布博客 在github的your_github_name.github.io上创建一个分支，名hexo 将hexo设置为默认分支 git clone your_github_name.github.io 到本地，然后将xxxBlog里面的文件都拷贝到your_github_name.github.io中，将theme中的.git文件删除，git add/commit 这些变更。 以后只要git pull这个分支，然后npm install就可以在其他的电脑上操作你的博客了。 Hexo 的基本操作 创建新博客 hexo new “create Blog” 创建单独页面 hexo new page xxx 本地构建服务 hexo server 本地html缓存清理 hexo clean html 生成 hexo generate html 部署 hexo deploy]]></content>
      <categories>
        <category>博客基础</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
