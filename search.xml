<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RunLoop回顾总结之 Thread-Loop Store]]></title>
    <url>%2F2018%2F05%2F08%2FRunLoopReviewSummary-TLM%2F</url>
    <content type="text"><![CDATA[概念一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。 1234567function eventLoop() &#123; initialize(); // 内部初始化 do&#123; let msg = getNextMsg(); // 获取下一个消息/事件 processMsg(msg); // 执行消息/事件 &#125; while (msg != quit); // 循环知道退出消息到达&#125; RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。 撸代码看设计RunLoop与线程之间的关系thread - runloop 是一对一 key-value 存储在进程中的全局Dict __CFRunLoops中。 核心代码CFRunLoop.c line:1353 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static pthread_t kNilPthreadT = (pthread_t)0; // 初始化 kNilPthreadT 为空线程static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。// 获取 runnLoop 的函数。CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; // 入参线程为空，则默认使用主线程。 __CFLock(&amp;loopsLock); // 操作 loops 前加锁。 if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。 __CFUnlock(&amp;loopsLock); // 解锁。 CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。 CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。 // 将 dict 赋值给 loops，内部有锁。 if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); // 释放临时变量dict。 &#125; CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。 __CFLock(&amp;loopsLock); // 加锁。 &#125; CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop __CFUnlock(&amp;loopsLock); // 解锁。 // loops 中没有线程 t 的 loop if (!loop) &#123; CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。 __CFLock(&amp;loopsLock); // 解锁。 loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。 // 二次校验 loops 中有没有线程 t 的 loop。 if (!loop) &#123; CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。 loop = newLoop; // 赋值给 loop。 &#125; // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFUnlock(&amp;loopsLock); // 解锁。 CFRelease(newLoop); // 释放 newLoop。 &#125; if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程 _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。 if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123; _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。 &#125; &#125; return loop; // 返回线程 t 的 loop。&#125;// 获取主线程的 mainLoop 函数CFRunLoopRef CFRunLoopGetMain(void) &#123; CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。 // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。 static CFRunLoopRef __main = NULL; // no retain needed // 不存在，则获取主线程的 mainLoop。 if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return __main;&#125;// 获取当前线程的 loop 函数CFRunLoopRef CFRunLoopGetCurrent(void) &#123; CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。 // TLS 中获取当前线程的 loop。 CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; // 不存在，则获取当前线程的 loop。 return _CFRunLoopGet0(pthread_self());&#125; 辅助函数 - TLS 操作函数CFPlatform.c line: 648 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 存储函数CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123; if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错 _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot); HALT; &#125; // 获取 TSL 中的 table __CFTSDTable *table = __CFTSDGetTable(); if (!table) &#123; // table 不存在，报错 // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore. _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot); return NULL; &#125; void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值 table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值 table-&gt;destructors[slot] = destructor; // 存储析构器 return oldVal; // 返回数据变更之前的值&#125;// 读取函数CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123; if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错 _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot); HALT; &#125; // 获取 TSL 中的 table __CFTSDTable *table = __CFTSDGetTable(); if (!table) &#123; // table 不存在，则报错 // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore. _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot); return NULL; &#125; uintptr_t *slots = (uintptr_t *)(table-&gt;data); return (void *)slots[slot]; // 按 key 从 data 中获取值并返回&#125;// 获取 TLS 的 tablestatic __CFTSDTable *__CFTSDGetTable() &#123; // 获取 TLS 的 table __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific(); // Make sure we&apos;re not setting data again after destruction. if (table == CF_TSD_BAD_PTR) &#123; // 被析构了 return NULL; &#125; // Create table on demand if (!table) &#123; // This memory is freed in the finalize function table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间 pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 __CFTSDSetSpecific(table); // 存储 table &#125; return table; //返回 table&#125;// table 获取函数static void *__CFTSDGetSpecific() &#123; return _pthread_getspecific_direct(CF_TSD_KEY);&#125; 流程图 总结 Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。 主线程的 RunLoop 是默认创建的，其他的线程的 RunLoop 是用时创建，懒加载的。 线程的 RunLoop 并不是每次都是从全局字典中获取的。这样可以加快获取的过程，有利于性能的提升。 主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。 其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。 未完，待续…引用 https://opensource.apple.com/tarballs/CF/ https://blog.csdn.net/ssirreplaceable/article/details/53793456 https://blog.ibireme.com/2015/05/18/runloop/ https://blog.csdn.net/ssirreplaceable/article/details/53793456 https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork]]></content>
      <categories>
        <category>RunLoop</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客]]></title>
    <url>%2F2018%2F05%2F06%2FopenMyBlog%2F</url>
    <content type="text"><![CDATA[基础环境配置 node.js 安装 git 环境安装 hexo 安装 npm install -g hexo-cli 权限不够请使用 sudo npm install -g hexo-cli GitHub 创建博客关联仓库 在gitHub上创建一个仓库，起名your_github_name.github.io 搭建博客 创建属于你的博客文件夹xxxBlog 并初始化 cd xxxBlog hexo init 导入依赖包 npm install 在上述步骤生成的_config.yml中定制配置 itle: Choose a titlesubtitle: Any subtitle you likedescription: Anything you likeauthor: Your namelanguage: zh-CNtimezone: Asia/Shanghaideploy:type: gitrepo: https://github.com/your_github_name/your_github_name.github.com.gitbranch: master 博客部署 开启本地验证 hexo server 安装部署器 npm install hexo-deployer-git –save 博客部署到GitHub上 hexo deploy 浏览器your_github_name.github.io访问部署以后的博客 博客主题切换 挑选自己喜欢的主题，Google上随便一搜hexo的主题多的是，我自己使用的是Maupassant的主题，屠夫的优化版。 git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 安装主题和渲染器 npm install hexo-renderer-jade –save npm install hexo-renderer-sass –save 重新编辑xxxBlog下的_config.yml文件 将theme的值改为maupassant hexo三部曲 hexo clean hexo g hexo deploy 浏览器your_github_name.github.io访问部署以后的新主题的博客 404页面配置 在source下创建一个404.html的文件 使用腾讯公益404代码，直接在html中写如下代码&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 适配多电脑发布博客 在github的your_github_name.github.io上创建一个分支，名hexo 将hexo设置为默认分支 git clone your_github_name.github.io 到本地，然后将xxxBlog里面的文件都拷贝到your_github_name.github.io中，将theme中的.git文件删除，git add/commit 这些变更。 以后只要git pull这个分支，然后npm install就可以在其他的电脑上操作你的博客了。 Hexo 的基本操作 创建新博客 hexo new “create Blog” 创建单独页面 hexo new page xxx 本地构建服务 hexo server 本地html缓存清理 hexo clean html 生成 hexo generate html 部署 hexo deploy]]></content>
      <categories>
        <category>博客基础</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
