<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RunLoop回顾总结之 Thread-Loop Store</title>
      <link href="/2018/05/08/RunLoopReviewSummary-TLM/"/>
      <url>/2018/05/08/RunLoopReviewSummary-TLM/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function eventLoop() &#123;</span><br><span class="line">    initialize(); // 内部初始化</span><br><span class="line">        do&#123;</span><br><span class="line">            let msg = getNextMsg(); // 获取下一个消息/事件</span><br><span class="line">            processMsg(msg); // 执行消息/事件</span><br><span class="line">        &#125; while (msg != quit); // 循环知道退出消息到达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。</p><h1 id="撸代码看设计"><a href="#撸代码看设计" class="headerlink" title="撸代码看设计"></a>撸代码看设计</h1><h2 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h2><p>thread - runloop 是一对一 key-value 存储在进程中的全局Dict __CFRunLoops中。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:1353</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static pthread_t kNilPthreadT = (pthread_t)0; // 初始化  kNilPthreadT 为空线程</span><br><span class="line">static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。</span><br><span class="line">static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。</span><br><span class="line"></span><br><span class="line">// 获取 runnLoop 的函数。</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125; // 入参线程为空，则默认使用主线程。</span><br><span class="line"></span><br><span class="line">    __CFLock(&amp;loopsLock); // 操作 loops 前加锁。</span><br><span class="line"></span><br><span class="line">    if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">    </span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。</span><br><span class="line">        // 将 dict 赋值给 loops，内部有锁。</span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; </span><br><span class="line">            CFRelease(dict); // 释放临时变量dict。</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 加锁。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop</span><br><span class="line">    __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line"></span><br><span class="line">    // loops 中没有线程 t 的 loop</span><br><span class="line">    if (!loop) &#123; </span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 解锁。</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。</span><br><span class="line">        // 二次校验 loops 中有没有线程 t 的 loop。</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。</span><br><span class="line">            loop = newLoop; // 赋值给 loop。</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">        CFRelease(newLoop); // 释放 newLoop。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop; // 返回线程 t 的 loop。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取主线程的 mainLoop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // 不存在，则获取主线程的 mainLoop。</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 loop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // TLS 中获取当前线程的 loop。</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    // 不存在，则获取当前线程的 loop。</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数-TLS-操作函数"><a href="#辅助函数-TLS-操作函数" class="headerlink" title="辅助函数 - TLS 操作函数"></a>辅助函数 - TLS 操作函数</h3><p><code>CFPlatform.c  line: 648</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 存储函数</span><br><span class="line">CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，报错</span><br><span class="line">        // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值</span><br><span class="line">    </span><br><span class="line">    table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值</span><br><span class="line">    table-&gt;destructors[slot] = destructor; // 存储析构器</span><br><span class="line">    </span><br><span class="line">    return oldVal; // 返回数据变更之前的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取函数</span><br><span class="line">CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，则报错</span><br><span class="line">        // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    uintptr_t *slots = (uintptr_t *)(table-&gt;data);</span><br><span class="line">    return (void *)slots[slot]; // 按 key 从 data 中获取值并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取 TLS 的 table</span><br><span class="line">static __CFTSDTable *__CFTSDGetTable() &#123;</span><br><span class="line">    // 获取 TLS 的 table</span><br><span class="line">    __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific();</span><br><span class="line">    // Make sure we&apos;re not setting data again after destruction.</span><br><span class="line">    if (table == CF_TSD_BAD_PTR) &#123; // 被析构了</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // Create table on demand</span><br><span class="line">    if (!table) &#123;</span><br><span class="line">        // This memory is freed in the finalize function</span><br><span class="line">        table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间</span><br><span class="line">        pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 </span><br><span class="line">        __CFTSDSetSpecific(table); // 存储 table</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return table; //返回 table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// table 获取函数</span><br><span class="line">static void *__CFTSDGetSpecific() &#123;</span><br><span class="line">    return _pthread_getspecific_direct(CF_TSD_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="../../../../images/runLoop/manageThreadLoop.png" alt="loop 创建流图"><br><img src="../../../../images/runLoop/getMainLoop.png" alt="mainLoop 获取流程"><br><img src="../../../../images/runLoop/getCurrentLoop.png" alt="currentLoop 获取流程"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。</li><li>主线程的 RunLoop 是默认创建的，其他的线程的 RunLoop 是用时创建，懒加载的。</li><li>线程的 RunLoop 并不是每次都是从全局字典中获取的。这样可以加快获取的过程，有利于性能的提升。<ul><li>主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。</li><li>其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。</li></ul></li></ul><h2 id="未完，待续…"><a href="#未完，待续…" class="headerlink" title="未完，待续…"></a>未完，待续…</h2><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></li><li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">https://blog.csdn.net/ssirreplaceable/article/details/53793456</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></li><li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">https://blog.csdn.net/ssirreplaceable/article/details/53793456</a></li><li><a href="https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork" target="_blank" rel="noopener">https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork</a></li></ul>]]></content>
      
      <categories>
          
          <category> RunLoop </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RunLoop </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开启我的博客</title>
      <link href="/2018/05/06/openMyBlog/"/>
      <url>/2018/05/06/openMyBlog/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h3><ol><li>node.js 安装</li><li>git 环境安装</li><li>hexo 安装 npm install -g hexo-cli 权限不够请使用 sudo npm install -g hexo-cli</li></ol><h3 id="GitHub-创建博客关联仓库"><a href="#GitHub-创建博客关联仓库" class="headerlink" title="GitHub 创建博客关联仓库"></a>GitHub 创建博客关联仓库</h3><ol><li>在gitHub上创建一个仓库，起名your_github_name.github.io</li></ol><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><ol><li><p>创建属于你的博客文件夹xxxBlog 并初始化</p><ul><li>cd xxxBlog</li><li>hexo init</li></ul></li><li><p>导入依赖包</p><ul><li>npm install</li></ul></li><li><p>在上述步骤生成的_config.yml中定制配置</p><ul><li>itle: Choose a title<br>subtitle: Any subtitle you like<br>description: Anything you like<br>author: Your name<br>language: zh-CN<br>timezone: Asia/Shanghai<br>deploy:<br>type: git<br>repo: <a href="https://github.com/your_github_name/your_github_name.github.com.git" target="_blank" rel="noopener">https://github.com/your_github_name/your_github_name.github.com.git</a><br>branch: master</li></ul></li></ol><h3 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h3><ol><li><p>开启本地验证</p><ul><li>hexo server</li></ul></li><li><p>安装部署器</p><ul><li>npm install hexo-deployer-git –save</li></ul></li><li><p>博客部署到GitHub上</p><ul><li>hexo deploy</li></ul></li><li><p>浏览器your_github_name.github.io访问部署以后的博客</p></li></ol><h3 id="博客主题切换"><a href="#博客主题切换" class="headerlink" title="博客主题切换"></a>博客主题切换</h3><ol><li><p>挑选自己喜欢的主题，Google上随便一搜hexo的主题多的是，我自己使用的是Maupassant的主题，屠夫的优化版。</p><ul><li>git clone <a href="https://github.com/tufu9441/maupassant-hexo.git" target="_blank" rel="noopener">https://github.com/tufu9441/maupassant-hexo.git</a> themes/maupassant</li></ul></li><li><p>安装主题和渲染器</p><ul><li>npm install hexo-renderer-jade –save</li><li>npm install hexo-renderer-sass –save</li></ul></li><li><p>重新编辑xxxBlog下的_config.yml文件</p><ul><li>将theme的值改为maupassant</li></ul></li><li><p>hexo三部曲</p><ul><li>hexo clean</li><li>hexo g</li><li>hexo deploy</li></ul></li><li><p>浏览器your_github_name.github.io访问部署以后的新主题的博客</p></li></ol><h3 id="404页面配置"><a href="#404页面配置" class="headerlink" title="404页面配置"></a>404页面配置</h3><ol><li>在source下创建一个404.html的文件</li><li>使用腾讯公益404代码，直接在html中写如下代码<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></li></ol><h3 id="适配多电脑发布博客"><a href="#适配多电脑发布博客" class="headerlink" title="适配多电脑发布博客"></a>适配多电脑发布博客</h3><ol><li>在github的your_github_name.github.io上创建一个分支，名hexo</li><li>将hexo设置为默认分支</li><li>git clone your_github_name.github.io 到本地，然后将xxxBlog里面的文件都拷贝到your_github_name.github.io中，将theme中的.git文件删除，git add/commit 这些变更。</li><li>以后只要git pull这个分支，然后npm install就可以在其他的电脑上操作你的博客了。</li></ol><h3 id="Hexo-的基本操作"><a href="#Hexo-的基本操作" class="headerlink" title="Hexo 的基本操作"></a>Hexo 的基本操作</h3><ol><li><p>创建新博客</p><ul><li>hexo new “create Blog”</li></ul></li><li><p>创建单独页面</p><ul><li>hexo new page xxx</li></ul></li><li><p>本地构建服务</p><ul><li>hexo server</li></ul></li><li><p>本地html缓存清理</p><ul><li>hexo clean</li></ul></li><li><p>html 生成</p><ul><li>hexo generate</li></ul></li><li><p>html 部署</p><ul><li>hexo deploy</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 博客基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
