<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CADisplayLink 回顾总结</title>
      <link href="/2018/05/18/iOS-RunLoop-Apply-CADisplayLink/"/>
      <url>/2018/05/18/iOS-RunLoop-Apply-CADisplayLink/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CADisplayLink 是一个保持和屏幕刷新率同步的定时器。之所以说是同步的而不是一样的，是因为 CADisplayLink 可以设置每几帧回调一次。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CADisplayLink 添加到 RunLoop 后，在每次 vsync 信号到来时，都会执行回调。vsync 信号是读取下一帧数据的时钟信号。由于没有源码，不知道确切的设计。但是从 CADisplayLink 的特性来猜想，CADisplayLink 可能是向 RunLoop 注册了某个 source1，在 source1 关联的 port 监听到屏幕刷新结束的时候，就回调，然后在 CADisplayLink 内部根据属性设定来决定是否需要对外回调。</p><h2 id="与其他两种定时器的比较"><a href="#与其他两种定时器的比较" class="headerlink" title="与其他两种定时器的比较"></a>与其他两种定时器的比较</h2><h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><ul><li>优点：<ul><li>与屏幕刷新率保持同步。</li><li>触发回调的时机相比其他定时器来说，要准确的多。</li></ul></li><li>缺点：<ul><li>不能被继承。</li><li>回调处理时间如果太长，会造成掉帧现象。</li><li>回调时间灵活度小，间隔时间只能是屏幕刷新间隔的整数倍。</li></ul></li></ul><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><ul><li>优点：<ul><li>回调时间灵活度大，可以随意设定时间。</li></ul></li><li>缺点：<ul><li>子线程中使用，需要开启 RunLoop，否则，无效。</li><li>一般需要注册到 RunLoop 的 commonMode 中使用，否则在视图滑动的时候，不会接受到定时器到时的回调。</li><li>回调时机准确度低，有延时。</li></ul></li></ul><h3 id="dispatch-source-t"><a href="#dispatch-source-t" class="headerlink" title="dispatch_source_t"></a>dispatch_source_t</h3><ul><li>优点：<ul><li>不受 runLoop mode 的影响，在视图滑动的时候也可以接受到回调。</li></ul></li><li>缺点：<ul><li>回调时机较准确，但是不是最准确。</li><li>在 GCD 内部管理的线程占满时，回调会阻塞延迟。</li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://www.jianshu.com/p/656d8ec3e678" target="_blank" rel="noopener">CADisplayLink(逐帧动画)</a></li><li><a href="https://www.jianshu.com/p/434ec6911148" target="_blank" rel="noopener">老司机带你走进Core Animation 之CADisplayLink</a></li><li><a href="http://v2it.win/ios/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cadisplaylink%E5%92%8Cnstimer/" target="_blank" rel="noopener">深入理解CADisplayLink、NSTimer和dispatch_source</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RunLoop </tag>
            
            <tag> CADisplayLink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AutoreleasePool 回顾总结</title>
      <link href="/2018/05/15/RunLoop-AutoreleasePool/"/>
      <url>/2018/05/15/RunLoop-AutoreleasePool/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AutoreleasePool 是 OC 中的一种内存延迟释放机制。正常情况下变量在其作用域结束便被释放，如果使用 autoreleasePool 包裹，则会延迟释放。除非手动干预 autoreleasePool 的释放，否则将在 runLoop 的休眠和退出的时机释放。</p><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>App 在启动后向主线程注册了两个Observer，监听 RunLoop 的 Entry/BeforeWaiting/Exit 三个时机。</p><ul><li>Observer1: 负责监听 entry 状态，创建 autoreleasePool(poolPush)，在32位上优先级是-(2^32-1)，最高优先级，保证后续所有操作都在这个 pool 中。</li><li>Observer2: 负责监听 beforeWaiting 和 exit 两个状态。优先级是 (2^32-1)，最低优先级，保证在所有操作之后，与 observer1 对应。<ul><li>beforeWaiting: 先销毁 autoreleasePool(poolPop)，释放 pool 中之前延迟释放的对象；然后再创建 autoreleasePool(poolPush)，为 afterWaiting 的操作做准备。</li><li>exit: 销毁 autoreleasePool(poolPop)，释放 pool 中之前延迟释放的对象。</li></ul></li><li>AutoReleasePool 是一个隐式的双向链表，每一个节点都是一个 autoreleasePoolPage(可见数据结构)，也就是一个内存页，大小为4k。</li><li>每一个线程都一个 autoreleasePool 栈，来管理与其关联的 autoreleasePool，当线程销毁时，所有相关联的 pool 都被销毁，并释放其中的对象。</li></ul><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/autoreleasePool/AutoreleasePool.png"><br></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><ul><li>自动释放池是用双向链表来实现的，充分利用内存页，能快速查询且 release 延时释放的对象。</li><li>以哨兵对象作为一次 push 进来的标志，便于 pop 的时候查找，哨兵对象实际就是一个 nil。</li><li>调用 autorelease 的时候，会将对象压入 autoreleasePoolPage 中。</li><li>pop 的时候会找到就近的哨兵对象，然后依次 release 对象，直到这个哨兵对象。</li><li>嵌套 autoreleasePool 的 pop，也是一层一层的找哨兵对象，然后释放对象。</li><li>iOS 的入口函数中表明整个 APP 的运行行为都是放在一个 autoreleasePool 的。</li><li>每个线程都有 autoreleasePool，且1对1。<ul><li>主线程的 autoreleasePool 是默认开启的。因为 RunLoop 是默认运行的，APP 在观察到 KCFRunLoopEntry 的时候就创建了 pool。</li><li>子线程的 runLoop 默认是不开启的。它的 pool 是在第一次调用 autorelease 的时候创建的。</li></ul></li><li>@autoreleasePool 语法糖的背后实现其实是一个局部 autoreleasePool 变量的生命周期。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)func &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // do something.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==&gt;</span><br><span class="line">- (void)func &#123;</span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; // 当 __autoreleasepool 析构的时候，自动释放池 pop</span><br><span class="line">    // do something.</span><br><span class="line">&#125;</span><br><span class="line">因为：</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">    ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">    void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/autoreleasePool/MemoryStructure.png"><br></figure><br><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/autoreleasePool/CoreProcess.png"><br></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><h4 id="Push-操作"><a href="#Push-操作" class="headerlink" title="Push 操作"></a>Push 操作</h4><p><code>NSObject.mm line:1881</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// push 函数</span><br><span class="line">void *objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用 AutoreleasePoolPage 的 push</span><br><span class="line">    return AutoreleasePoolPage::push(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#  define POOL_BOUNDARY nil // 每次 push 的起始标记，也叫哨兵</span><br><span class="line"></span><br><span class="line">// AutoreleasePoolPage 的 push 函数，以简化掉 debug 的兼容代码</span><br><span class="line">static inline void *push()</span><br><span class="line">&#123;</span><br><span class="line">    // 将 POOL_BOUNDARY 压入 autoreleasePoolPage 中，作为这次 autoreleasePool 的一个标记</span><br><span class="line">    id *dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br><span class="line">// 快速将对象压入 page 的函数 </span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage(); // 获取当前可用的 page</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123; // page 未满的时候，压入对象</span><br><span class="line">        return page-&gt;add(obj); // 压入对象</span><br><span class="line">    &#125; else if (page) &#123; // page 已满，需要创建新的 page，并压入对象</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123; // 当前没有 page，是一个空链表</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// page 要溢出时的处理函数</span><br><span class="line">static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    assert(page == hotPage()); // 断言一定是当前可用的 page</span><br><span class="line">    assert(page-&gt;full()); // 断言 page 一定满了</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child; // 使用下一个 page</span><br><span class="line">        else page = new AutoreleasePoolPage(page); // 创建新 page，并加入到链表中</span><br><span class="line">    &#125; while (page-&gt;full()); // 只有 page 满的情况才执行</span><br><span class="line">    </span><br><span class="line">    setHotPage(page); // 重新设定当前可用 page，并存储在 TLS 中</span><br><span class="line">    return page-&gt;add(obj); // 把目标对象压入 page</span><br><span class="line">&#125;</span><br><span class="line">// 空链表的时候处理的函数</span><br><span class="line">static __attribute__((noinline)) id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!hotPage()); // 断言当前没有可用的 page</span><br><span class="line">    </span><br><span class="line">    bool pushExtraBoundary = false; // 是否添加哨兵的标志位</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123; // 有占位的 page</span><br><span class="line">        pushExtraBoundary = true; // 需要添加哨兵</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj != POOL_BOUNDARY) &#123; // 目标对象不是哨兵</span><br><span class="line">        // We are pushing an object with no pool in place,</span><br><span class="line">        // and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     pthread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj == POOL_BOUNDARY) &#123; // 目标对象是哨兵</span><br><span class="line">        return setEmptyPoolPlaceholder(); // 添加一个占位的 page</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    创建链表中的第一个节点 page</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page); // 设置当前可用的 page</span><br><span class="line">    </span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY); // 添加哨兵</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Push the requested object or pool.</span><br><span class="line">    return page-&gt;add(obj); // page 压入对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Pop-操作"><a href="#Pop-操作" class="headerlink" title="Pop 操作"></a>Pop 操作</h4><p><code>NSObject.mm line:1886</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// pop 函数</span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用 AutoreleasePoolPage 的 pop</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line">// AutoreleasePoolPage 的 pop 函数，token 为 push 函数的返回值</span><br><span class="line">static inline void pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    </span><br><span class="line">    // token 是占位 page</span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        if (hotPage()) &#123; // 当前有可用的 page</span><br><span class="line">            pop(coldPage()-&gt;begin()); // 从第一个不可用的 page 的第一个压入的对象开始递归</span><br><span class="line">        &#125; else &#123; // 当前 page 为空，说明 pool 没有被使用</span><br><span class="line">            setHotPage(nil); // 设置当前 page 为空</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    page = pageForPointer(token); // 查找 token 所在的 page</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123; // token 不是哨兵</span><br><span class="line">        // 一些错误的处理</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Error. For bincompat purposes this is not</span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (PrintPoolHiwat) printHiwat(); // 重新计算最高水位</span><br><span class="line">    </span><br><span class="line">    page-&gt;releaseUntil(stop); // 释放对象知道遇到 token，也就是哨兵</span><br><span class="line">    </span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Objc-autorelease-操作"><a href="#Objc-autorelease-操作" class="headerlink" title="Objc autorelease 操作"></a>Objc autorelease 操作</h4><p><code>NSObject.mm line:2331</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// autorelease 外部可用 API</span><br><span class="line">- (id)autorelease &#123;</span><br><span class="line">    return ((id)self)-&gt;rootAutorelease(); // 调用 objc_object 的 autorelease 方法</span><br><span class="line">&#125;</span><br><span class="line">// objc_object 的 autorelease 函数</span><br><span class="line">inline id objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    // 被 TaggedPointer 标记，优化内存占用，指针值不是地址，而是值</span><br><span class="line">    if (isTaggedPointer()) return (id)this; </span><br><span class="line">    // TLS + __builtin_return_address 内存优化</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2(); // 继续调用另一个 autorelease 的函数</span><br><span class="line">&#125;</span><br><span class="line">// autorelease2 函数</span><br><span class="line">__attribute__((noinline,used)) id objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this); // 开始调用 autoreleasePoolPage 的 autorelease 函数，此处开始进入到 autoreleasePool 了。</span><br><span class="line">&#125;</span><br><span class="line">// autoreleasePoolPage 的 autorelease 函数</span><br><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj); // 插入到 autoreleasePoolPage</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#  define EMPTY_POOL_PLACEHOLDER ((id*)1) // 只是一个占位的 page</span><br><span class="line"></span><br><span class="line">// 获取当前可用的 page</span><br><span class="line">static inline AutoreleasePoolPage *hotPage()</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">    tls_get_direct(key); // TLS 中查找保存的 page</span><br><span class="line">    // 遇到占位 page，则无可用 page</span><br><span class="line">    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck(); // 对 page 结构的完整性做校验</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">// 设置当前可用的 page</span><br><span class="line">static inline void setHotPage(AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    if (page) page-&gt;fastcheck(); // page 完整性校验</span><br><span class="line">    tls_set_direct(key, (void *)page); // TLS 存储</span><br><span class="line">&#125;</span><br><span class="line">// 构造函数</span><br><span class="line">AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">: magic(), next(begin()), thread(pthread_self()),</span><br><span class="line">parent(newParent), child(nil),</span><br><span class="line">depth(parent ? 1+parent-&gt;depth : 0),</span><br><span class="line">hiwat(parent ? parent-&gt;hiwat : 0)</span><br><span class="line">&#123;</span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        assert(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        parent-&gt;child = this; // 将新的节点加入到链表中</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否有空的占位的 page</span><br><span class="line">static inline bool haveEmptyPoolPlaceholder()</span><br><span class="line">&#123;</span><br><span class="line">    id *tls = (id *)tls_get_direct(key);</span><br><span class="line">    return (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br><span class="line">// 添加占位的 page</span><br><span class="line">static inline id* setEmptyPoolPlaceholder()</span><br><span class="line">&#123;</span><br><span class="line">    assert(tls_get_direct(key) == nil);</span><br><span class="line">    tls_set_direct(key, (void *)EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">    return EMPTY_POOL_PLACEHOLDER;</span><br><span class="line">&#125;</span><br><span class="line">// 链表中第一个不可用的 page</span><br><span class="line">static inline AutoreleasePoolPage *coldPage()</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *result = hotPage(); // 获取当前 page</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        while (result-&gt;parent) &#123; // 一直反向遍历</span><br><span class="line">            result = result-&gt;parent;</span><br><span class="line">            result-&gt;fastcheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">// 释放函数</span><br><span class="line">void releaseUntil(id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    // Not recursive: we don&apos;t want to blow out the stack</span><br><span class="line">    // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    </span><br><span class="line">    // 清理到哨兵</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage(); // 当前 page</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page); // 安全策略，重置当前 page</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        page-&gt;unprotect(); // 允许 write 操作</span><br><span class="line">        id obj = *--page-&gt;next; // 找到 next 之前的对象，next 指向的是下一个可用的空地址</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); // 内存清理</span><br><span class="line">        page-&gt;protect(); // 关闭 write 操作</span><br><span class="line">        </span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123; // 非哨兵</span><br><span class="line">            objc_release(obj); // 想对象发送 release 消息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setHotPage(this); // 重置当前 page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联知识"><a href="#关联知识" class="headerlink" title="关联知识"></a>关联知识</h2><ul><li>Tagged Pointer<ul><li>Tagged Pointer 是用来存储一些轻量级的对象，来优化内存管理。比如 NSNumber 等。</li><li>Tagged Pointer 的指针不再是地址了，而是真正的值。不存储在堆上。</li><li>内存读取有3倍效率，创建是以前的106倍。</li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">源码</a></li><li><a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">AutoreleasePool的原理和实现</a></li><li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></li><li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="noopener">Objective-C Autorelease Pool 的实现原理</a></li><li><a href="https://juejin.im/post/5a66e28c6fb9a01cbf387da1" target="_blank" rel="noopener">iOS开发笔记（七）：深入理解 Autorelease</a></li><li><a href="https://blog.csdn.net/xiejunyi12/article/details/61195716" target="_blank" rel="noopener">Objective-C Target Point</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> autorelease </tag>
            
            <tag> autoreleasePool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RunLoop 回顾总结</title>
      <link href="/2018/05/08/RunLoopReviewSummary/"/>
      <url>/2018/05/08/RunLoopReviewSummary/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function eventLoop() &#123;</span><br><span class="line">    initialize(); // 内部初始化</span><br><span class="line">        do&#123;</span><br><span class="line">            let msg = getNextMsg(); // 获取下一个消息/事件</span><br><span class="line">            processMsg(msg); // 执行消息/事件</span><br><span class="line">        &#125; while (msg != quit); // 循环知道退出消息到达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/RunLoopApply.png"><br></figure><h1 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h1><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/RunLoopStructureChart.png"><br></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="Loop-Thread-Relation"><a href="#Loop-Thread-Relation" class="headerlink" title="Loop - Thread Relation"></a>Loop - Thread Relation</h2><ul><li>Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。</li><li>主线程的 RunLoop 是默认创建的，其他线程的 RunLoop 是用时创建，懒加载的。</li><li>线程的 RunLoop 并不是每次都是从全局字典中获取的，而是从全局或者 TLS 中获取。这样可以加快获取的过程，有利于性能的提升。<ul><li>主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。</li><li>其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。</li></ul></li><li>CFRunLoop 中使用了锁来保证线程安全。NSRunLoop 是基于 CFRunLoop 封装的，没有设计线程安全。</li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/ThreadLoopRelation.png"><br></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:1353</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static pthread_t kNilPthreadT = (pthread_t)0; // 初始化  kNilPthreadT 为空线程</span><br><span class="line">static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。</span><br><span class="line">static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。</span><br><span class="line"></span><br><span class="line">// 获取 runnLoop 的函数。</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125; // 入参线程为空，则默认使用主线程。</span><br><span class="line"></span><br><span class="line">    __CFLock(&amp;loopsLock); // 操作 loops 前加锁。</span><br><span class="line"></span><br><span class="line">    if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">    </span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。</span><br><span class="line">        // 将 dict 赋值给 loops，内部有锁。</span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; </span><br><span class="line">            CFRelease(dict); // 释放临时变量dict。</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 加锁。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop</span><br><span class="line">    __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line"></span><br><span class="line">    // loops 中没有线程 t 的 loop</span><br><span class="line">    if (!loop) &#123; </span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 解锁。</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。</span><br><span class="line">        // 二次校验 loops 中有没有线程 t 的 loop。</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。</span><br><span class="line">            loop = newLoop; // 赋值给 loop。</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">        CFRelease(newLoop); // 释放 newLoop。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop; // 返回线程 t 的 loop。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取主线程的 mainLoop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // 不存在，则获取主线程的 mainLoop。</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 loop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // TLS 中获取当前线程的 loop。</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    // 不存在，则获取当前线程的 loop。</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="辅助代码"><a href="#辅助代码" class="headerlink" title="辅助代码"></a>辅助代码</h3><h4 id="TLS-操作函数"><a href="#TLS-操作函数" class="headerlink" title="TLS 操作函数"></a>TLS 操作函数</h4><p><code>CFPlatform.c  line: 648</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 存储函数</span><br><span class="line">CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，报错</span><br><span class="line">        // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值</span><br><span class="line">    </span><br><span class="line">    table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值</span><br><span class="line">    table-&gt;destructors[slot] = destructor; // 存储析构器</span><br><span class="line">    </span><br><span class="line">    return oldVal; // 返回数据变更之前的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取函数</span><br><span class="line">CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，则报错</span><br><span class="line">        // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    uintptr_t *slots = (uintptr_t *)(table-&gt;data);</span><br><span class="line">    return (void *)slots[slot]; // 按 key 从 data 中获取值并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取 TLS 的 table</span><br><span class="line">static __CFTSDTable *__CFTSDGetTable() &#123;</span><br><span class="line">    // 获取 TLS 的 table</span><br><span class="line">    __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific();</span><br><span class="line">    // Make sure we&apos;re not setting data again after destruction.</span><br><span class="line">    if (table == CF_TSD_BAD_PTR) &#123; // 被析构了</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // Create table on demand</span><br><span class="line">    if (!table) &#123;</span><br><span class="line">        // This memory is freed in the finalize function</span><br><span class="line">        table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间</span><br><span class="line">        pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 </span><br><span class="line">        __CFTSDSetSpecific(table); // 存储 table</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return table; //返回 table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// table 获取函数</span><br><span class="line">static void *__CFTSDGetSpecific() &#123;</span><br><span class="line">    return _pthread_getspecific_direct(CF_TSD_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Loop-Run"><a href="#Loop-Run" class="headerlink" title="Loop Run"></a>Loop Run</h2><ul><li>RunLoop 实质上是一个 do…While 的循环，通过 port trap 消息来执行。</li><li>RunLoop 有五种运行 mode，每个 mode 中有多个 modeItem。<ul><li>kCFRunLoopDefaultMode: 默认运行 mode。</li><li>UITrackingRunLoopMode: 界面追踪 mode，用户追踪 scrollView 的滑动。</li><li>UIInitializationRunLoopMode: 启动初始化 mode，只在该 mode 下运行一次。</li><li>GSEventReceiveRunLoopMode：系统内部事件的 mode。</li><li>kCFRunLoopCommonModes：一个集合，集合其他 mode。</li><li>ModeItem: Source/Timer/Observer 的统称，没有实际的数据结构。</li><li>CommonModes: 标记为 common 的 mode，这些 mode 的 modeItem 是相同的。可以使得 RunLoop 可以看似在多个 mode 下共同运行。</li><li>CommonModeItems: common mode 下运行的事件集合。</li></ul></li><li>事件类型：<ul><li>Timer: 与 NSTimer 是 Toll-Free Bridging 的，基于时间的触发源。多个 Timer 对应一个modeQueuePort。</li><li>Source0: 只有 block，没有 port，用户级事件。多个 source0 对应一个 wakeupPort，当 source0 被标记后，会通过 wakeupPort 唤醒执行。</li><li>Source1: 有 blok 和 port，系统级事件。</li><li>Observer: 对 loop 过程的一个监听。<ul><li>KCFRunLoopEntry: loop 进入。</li><li>KCFRunLoopBeforeTimers: 开始处理Timers。</li><li>KCFRunLoopBeforeSources: 开始处理Source。</li><li>KCFRunLoopBeforeWaiting: 开始休眠。</li><li>KCFRunLoopAfterWaiting: 结束休眠。</li><li>KCFRunLoopExit: loop 退出。</li></ul></li></ul></li><li>RunLoop 在处理完 source0 后多空转一次，是为了保证source0被确切的执行完毕。</li><li>RunLoop 只能在单一 Mode 下运行，切换 mode 后会保存之前 mode 的运行数据。新 mode 下运行结束后，并不会继续之前的 mode 下重新 run，但是会还原之前的运行数据。</li><li>RunLoop 的 block 是用单向链表存储的，在第一次运行完 block 的时候会变更为环形链表，便于后续 block 执行的查找。block 猜测是 dispatch 过来的。</li><li>perform…selector 最后对应的是一个定时器事件。</li></ul><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/run.png"><br></figure><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:2649</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">// mode 切换函数 </span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK(); // 进程检查</span><br><span class="line">    // 检查loop是否被析构</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl); // 加锁</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 查找对应 modeName 的 mode 且对 mode 加锁</span><br><span class="line">    // 判断 mode 是否有效</span><br><span class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        Boolean did = false;</span><br><span class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode); // mode 解锁</span><br><span class="line">        __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished; // 返回运行结果</span><br><span class="line">    &#125;</span><br><span class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); // 记录当前 mode 的运行数据，并将当前数据置位，准备给新的 mode 使用</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode; // 记录当前 mode</span><br><span class="line">    rl-&gt;_currentMode = currentMode; // 变更 loop 的 mode 为目标 mode</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished; // 初始化一个运行结果</span><br><span class="line">    </span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 发出 entry 通知</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 执行 run 函数</span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); // 发出 exit 通知</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopModeUnlock(currentMode); // mode 解锁</span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun); // 将记录的之前的 mode 的运行数据还原</span><br><span class="line">    rl-&gt;_currentMode = previousMode; // 将记录的之前的 mode 还原</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">    return result; // 返回目标 mode 的运行结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Run 函数，已经把架构指令集适配代码简化掉了</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time(); // 获取机器时间</span><br><span class="line">    </span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123; // 判断 loop 是够已经停止</span><br><span class="line">        __CFRunLoopUnsetStopped(rl); // 置位状态</span><br><span class="line">        return kCFRunLoopRunStopped; // 返回状态</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123; // 对应的 mode 是否已经停止</span><br><span class="line">        rlm-&gt;_stopped = false; // 置位状态</span><br><span class="line">        return kCFRunLoopRunStopped; // 返回状态</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL; // 给dispatch 初始化一个空端口</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); // 判断是否第一次配发到主线程</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); // 在主线程下，会给 dispatch 配置一个 port</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL; // 给 modeQueue 初始化一个空 port，查看全文代码，queue 里面只是存储了 timer</span><br><span class="line">    if (rlm-&gt;_queue) &#123; // queue 存在</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue); // 配置一个 port</span><br><span class="line">        if (!modeQueuePort) &#123; // 配置 port 失败，报错</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer = NULL; // 初始化一个空timer，用来做 loop 超时监测的</span><br><span class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); // 超时上下文内存初始化</span><br><span class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">        seconds = 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR = 0ULL; // 超时时间为0</span><br><span class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; // 判断是够在限制时间间隔之内</span><br><span class="line">        dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); // 根据线程分配队列</span><br><span class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 创建定时器</span><br><span class="line">        dispatch_retain(timeout_timer); // 增加引用计数</span><br><span class="line">        // 配置上下文</span><br><span class="line">        timeout_context-&gt;ds = timeout_timer; // 设置 timer</span><br><span class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); // 设置 loop</span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); // 设置时间</span><br><span class="line">        // 设置上下文</span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">        // 设置超时操作</span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        // 设置取消操作</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        // 设置超时定时器</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        // 启动定时器</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; // infinite timeout</span><br><span class="line">        seconds = 9999999999.0; </span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX; // 设置最大超时时间</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Boolean didDispatchPortLastTime = true; // 初始化 dispatch port 的标记</span><br><span class="line">    int32_t retVal = 0; // 运行结果初始化</span><br><span class="line">    // 进入主体事件循环</span><br><span class="line">    do &#123;</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = NULL;</span><br><span class="line">        uint8_t msg_buffer[3 * 1024]; // 初始化一个 msg 的缓冲</span><br><span class="line"></span><br><span class="line">        mach_msg_header_t *msg = NULL; // msg</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL; // 当前活动的 port，初始化为 null</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet; // 待监听的 port 的集合</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl); // 设置可唤醒状态</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知要处理 timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理要处理 sources, 这里是 source0</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm); // 执行 block，从代码上猜测应该是 dispatch 塞进的 block，使用双向链表保存</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); // 执行可以执行的 source0</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm); // 执行block</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); // source 被执行完 或者 loop 超时，需要再空转一圈，来保证 source0 被彻底执行完，因为 source0 不具备主动唤醒能力，只能被动执行</span><br><span class="line">        </span><br><span class="line">        // 第一次不会执行</span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; // 是否是 dispatch 的 port </span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer; // 缓冲中取 msg</span><br><span class="line">            // 监听 port 中消息</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">                goto handle_msg; // 跳转到消息执行体</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = false; // 置位</span><br><span class="line">        </span><br><span class="line">        // 通知即将要休眠</span><br><span class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl); // 设置 sleep 状态</span><br><span class="line">        // do not do any user callouts after this point (after notifying of sleeping)</span><br><span class="line">        </span><br><span class="line">        // Must push the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced.</span><br><span class="line">        </span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet); // 收敛所有的 port</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm); // 解锁 mode</span><br><span class="line">        __CFRunLoopUnlock(rl); // 解锁 loop</span><br><span class="line">        </span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent(); // 记录休眠开始时间点</span><br><span class="line">        </span><br><span class="line">        // 进入内部监听循环体，只要跳出该循环体，则代表 loop 被唤醒</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                // objc_clear_stack(0);</span><br><span class="line">                // &lt;rdar://problem/16393959&gt;</span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer)); // 清空缓冲区</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); // 监听 port 集合</span><br><span class="line">            </span><br><span class="line">            // 是否为 modeQueuePort，用来处理 timers </span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; </span><br><span class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br><span class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue)); // 遍历 modeQueue，判断是否有 timer 到时了</span><br><span class="line">                // 到时，则置位，且跳出内部循环体</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123; </span><br><span class="line">                    // Leave livePort as the queue port, and service timers below</span><br><span class="line">                    rlm-&gt;_timerFired = false; // 置位</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123; // 继续读取 msg</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 非 modeQueuePort 的 port msg 被捕获，则跳出内部循环体</span><br><span class="line">                // Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl); // 加锁 loop</span><br><span class="line">        __CFRunLoopModeLock(rlm); // 加锁 mode</span><br><span class="line">        </span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart)); // 记录自己的休眠时间</span><br><span class="line">        </span><br><span class="line">        // Must remove the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</span><br><span class="line">        // in there if this function returns.</span><br><span class="line">        </span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet); // 将 dispatchPort 从监听集合中移除</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，因为已经醒来了</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl); // 置位 sleep 标记</span><br><span class="line">        // 通知结束休眠</span><br><span class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); </span><br><span class="line">        </span><br><span class="line">        // 消息执行体</span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，对应 handle_msg 之前的设置</span><br><span class="line">        </span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123; // 是否为空 port</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING(); // 标记自己被唤醒的原因是“啥事也没发生”，一种兜底方案吧</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; // 是否为唤醒 port </span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP(); // 被唤醒 port 唤醒</span><br><span class="line">            // do nothing on Mac OS</span><br><span class="line">        &#125;</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; // 是否为 modeQueuePort</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER(); // 标记为被 Timer 事件唤醒</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // 根据机器事件执行 timer，但为成功</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl); // 再次执行 timer </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (livePort == dispatchPort) &#123; // 是否为 dispatch 的 port</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH(); // 标记唤醒的原因是 dispatch</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // 解锁 mode</span><br><span class="line">            __CFRunLoopUnlock(rl); // 解锁 loop</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);f</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            __CFRunLoopLock(rl); // 加锁 loop</span><br><span class="line">            __CFRunLoopModeLock(rlm); // 加锁 mode</span><br><span class="line">            sourceHandledThisLoop = true;  // 标记执行了 source</span><br><span class="line">            didDispatchPortLastTime = true; // 标记 dispatch 的 port 换新被执行完</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE(); // 标记唤醒的原因是 source</span><br><span class="line">            </span><br><span class="line">            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</span><br><span class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line">            </span><br><span class="line">            // Despite the name, this works for windows handles as well</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); // 获取对应 port 的 source1</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">                mach_msg_header_t *reply = NULL;</span><br><span class="line">                // 执行 source1</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                if (NULL != reply) &#123;</span><br><span class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm); // 执行 block</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource; // 处理完事件的运行结果</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut; // 超时运行结果</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl); // 置位</span><br><span class="line">            retVal = kCFRunLoopRunStopped; // 停止的运行结果</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123; </span><br><span class="line">            rlm-&gt;_stopped = false; // 置位</span><br><span class="line">            retVal = kCFRunLoopRunStopped; // 停止的运行结果</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; // mode 已经被执行完了</span><br><span class="line">            retVal = kCFRunLoopRunFinished; // 结束的运行结果</span><br><span class="line">        &#125;</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">        </span><br><span class="line">    &#125; while (0 == retVal); // 外层循环执行的条件判断</span><br><span class="line">    </span><br><span class="line">    // 释放超时定时器</span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="辅助代码-1"><a href="#辅助代码-1" class="headerlink" title="辅助代码"></a>辅助代码</h3><h4 id="Loop-运行数据-push-pop-函数"><a href="#Loop-运行数据-push-pop-函数" class="headerlink" title="Loop 运行数据 push/pop 函数"></a>Loop 运行数据 push/pop 函数</h4><p><code>CFRunLoop.c line:660</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// push 函数</span><br><span class="line">CF_INLINE volatile _per_run_data *__CFRunLoopPushPerRunData(CFRunLoopRef rl) &#123;</span><br><span class="line">    volatile _per_run_data *previous = rl-&gt;_perRunData; // 保存之前的运行数据</span><br><span class="line">    rl-&gt;_perRunData = (volatile _per_run_data *)CFAllocatorAllocate(kCFAllocatorSystemDefault, sizeof(_per_run_data), 0); // 重新创建一个运行数据</span><br><span class="line">    // 对运行数据做初始化置位</span><br><span class="line">    rl-&gt;_perRunData-&gt;a = 0x4346524C;</span><br><span class="line">    rl-&gt;_perRunData-&gt;b = 0x4346524C; // &apos;CFRL&apos;</span><br><span class="line">    rl-&gt;_perRunData-&gt;stopped = 0x00000000;</span><br><span class="line">    rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x00000000;</span><br><span class="line">    return previous; // 返回当前的运行数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pop 函数</span><br><span class="line">CF_INLINE void __CFRunLoopPopPerRunData(CFRunLoopRef rl, volatile _per_run_data *previous) &#123;</span><br><span class="line">    // 判断当前的运行数据是否存在</span><br><span class="line">    if (rl-&gt;_perRunData) CFAllocatorDeallocate(kCFAllocatorSystemDefault, (void *)rl-&gt;_perRunData // 存在，则销毁</span><br><span class="line">    rl-&gt;_perRunData = previous; // 切换运行数据为上一次的运行数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Observer-Timer-Source-操作函数"><a href="#Observer-Timer-Source-操作函数" class="headerlink" title="Observer/Timer/Source 操作函数"></a>Observer/Timer/Source 操作函数</h4><p>操作函数基本类似，这里以 observer 的操作为例做代码展开。<br><code>CFRunLoop.c line:1668</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">// 执行 Observer</span><br><span class="line">static void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;/* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    </span><br><span class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0; // observer 个数获取</span><br><span class="line">    if (cnt &lt; 1) return; // 没有则退出</span><br><span class="line">    </span><br><span class="line">    /* Fire the observers */</span><br><span class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);</span><br><span class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef)); // 创建一个 observer 的集合</span><br><span class="line">    CFIndex obs_cnt = 0;</span><br><span class="line">    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">        if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</span><br><span class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo); // 将未被执行的有效的 observer 保存到 observer 的集合中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">    for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</span><br><span class="line">        __CFRunLoopObserverLock(rlo); // observer 加锁</span><br><span class="line">        if (__CFIsValid(rlo)) &#123;</span><br><span class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</span><br><span class="line">            __CFRunLoopObserverSetFiring(rlo); // 设置执行状态</span><br><span class="line">            __CFRunLoopObserverUnlock(rlo); // observer 解锁</span><br><span class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info); // 执行 observer</span><br><span class="line">            if (doInvalidate) &#123;</span><br><span class="line">                CFRunLoopObserverInvalidate(rlo); // 设置失效状态</span><br><span class="line">            &#125;</span><br><span class="line">            __CFRunLoopObserverUnsetFiring(rlo); // 清除执行状态</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            __CFRunLoopObserverUnlock(rlo); // observer 解锁</span><br><span class="line">        &#125;</span><br><span class="line">        CFRelease(rlo);</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    __CFRunLoopModeLock(rlm); // mode 加锁</span><br><span class="line">    </span><br><span class="line">    if (collectedObservers != buffer) free(collectedObservers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加 observer</span><br><span class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return; // loop 析构的时候退出</span><br><span class="line">    if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return; // observer 和 loop 校验 </span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123; // common 标记的 mode 的处理</span><br><span class="line">        // 获取 common 标记的 mode 的集合</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        // 获取 common 标记的 modeItem 的集合</span><br><span class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 observer 添加到 common 标记的 modeItem 的集合中</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rlo&#125;;</span><br><span class="line">            /* add new item to all common-modes */</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rlm = __CFRunLoopFindMode(rl, modeName, true); // 查询 mode</span><br><span class="line">        // observer 的集合校验，为空则创建</span><br><span class="line">        if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</span><br><span class="line">            rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        // 查询 observer 是否已经存在，不存在，则添加</span><br><span class="line">        if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</span><br><span class="line">            Boolean inserted = false;</span><br><span class="line">            for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</span><br><span class="line">                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">                if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</span><br><span class="line">                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</span><br><span class="line">                    inserted = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 不存在，则添加</span><br><span class="line">            if (!inserted) &#123;</span><br><span class="line">                CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</span><br><span class="line">            &#125;</span><br><span class="line">            rlm-&gt;_observerMask |= rlo-&gt;_activities;</span><br><span class="line">            __CFRunLoopObserverSchedule(rlo, rl, rlm); // 对 observer 中的记录的 loop count 做变更</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除 observer</span><br><span class="line">void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123; // 是否为 common 标记的 mode </span><br><span class="line">        // common 标记的 mode 集合中是否存在目标 observer</span><br><span class="line">        if (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rlo)) &#123;</span><br><span class="line">            CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">            CFSetRemoveValue(rl-&gt;_commonModeItems, rlo); // 从 common 标记的 modeItem 的集合中移除目标 observer</span><br><span class="line">            if (NULL != set) &#123;</span><br><span class="line">                CFTypeRef context[2] = &#123;rl, rlo&#125;;</span><br><span class="line">                /* remove new item from all common-modes */</span><br><span class="line">                CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (void *)context);</span><br><span class="line">                CFRelease(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rlm = __CFRunLoopFindMode(rl, modeName, false); // 查询 mode</span><br><span class="line">        // observer 集合校验</span><br><span class="line">        if (NULL != rlm &amp;&amp; NULL != rlm-&gt;_observers) &#123;</span><br><span class="line">            CFRetain(rlo);</span><br><span class="line">            CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo); // 查找 observer </span><br><span class="line">            if (kCFNotFound != idx) &#123;</span><br><span class="line">                CFArrayRemoveValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">                __CFRunLoopObserverCancel(rlo, rl, rlm); // 变更 observer 中记录的 loop count </span><br><span class="line">            &#125;</span><br><span class="line">            CFRelease(rlo);</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Block-操作函数"><a href="#Block-操作函数" class="headerlink" title="Block 操作函数"></a>Block 操作函数</h4><p><code>CFRunLoop.c line:1618</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// 执行 block 函数</span><br><span class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</span><br><span class="line">    // blocks 链表校验</span><br><span class="line">    if (!rl-&gt;_blocks_head) return false;</span><br><span class="line">    // mode 校验</span><br><span class="line">    if (!rlm || !rlm-&gt;_name) return false;</span><br><span class="line">    Boolean did = false;</span><br><span class="line">    // 获取链表的表头</span><br><span class="line">    struct _block_item *head = rl-&gt;_blocks_head;</span><br><span class="line">    // 获取链表的表尾</span><br><span class="line">    struct _block_item *tail = rl-&gt;_blocks_tail;</span><br><span class="line">    rl-&gt;_blocks_head = NULL;</span><br><span class="line">    rl-&gt;_blocks_tail = NULL;</span><br><span class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</span><br><span class="line">    CFStringRef curMode = rlm-&gt;_name;</span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    struct _block_item *prev = NULL;</span><br><span class="line">    struct _block_item *item = head; // 从头开始遍历</span><br><span class="line">    while (item) &#123;</span><br><span class="line">        struct _block_item *curr = item;</span><br><span class="line">        item = item-&gt;_next;</span><br><span class="line">        Boolean doit = false;</span><br><span class="line">        // 校验是否执行</span><br><span class="line">        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">            doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125;</span><br><span class="line">        // 不执行，则还原</span><br><span class="line">        if (!doit) prev = curr;</span><br><span class="line">        // 执行，则继续向后遍历</span><br><span class="line">        if (doit) &#123;</span><br><span class="line">            // 变更链表的头尾</span><br><span class="line">            if (prev) prev-&gt;_next = item;</span><br><span class="line">            if (curr == head) head = item;</span><br><span class="line">            if (curr == tail) tail = prev;</span><br><span class="line">            void (^block)(void) = curr-&gt;_block;</span><br><span class="line">            CFRelease(curr-&gt;_mode);</span><br><span class="line">            free(curr);</span><br><span class="line">            // 执行 block</span><br><span class="line">            if (doit) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">                did = true;</span><br><span class="line">            &#125;</span><br><span class="line">            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    // 环形链表变更</span><br><span class="line">    if (head) &#123;</span><br><span class="line">        tail-&gt;_next = rl-&gt;_blocks_head;</span><br><span class="line">        rl-&gt;_blocks_head = head;</span><br><span class="line">        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    return did;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// block 存储函数</span><br><span class="line">void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    // mode 类型的判断</span><br><span class="line">    if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure mode exists</span><br><span class="line">        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true); // 查询 mode，没有则创建</span><br><span class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">    &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);</span><br><span class="line">        const void **values = (const void **)malloc(sizeof(const void *) * cnt);</span><br><span class="line">        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);</span><br><span class="line">        mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure modes exist</span><br><span class="line">        for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</span><br><span class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        free(values);</span><br><span class="line">    &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        CFIndex cnt = CFSetGetCount((CFSetRef)mode);</span><br><span class="line">        const void **values = (const void **)malloc(sizeof(const void *) * cnt);</span><br><span class="line">        CFSetGetValues((CFSetRef)mode, values);</span><br><span class="line">        mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure modes exist</span><br><span class="line">        for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</span><br><span class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        free(values);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mode = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    block = Block_copy(block);</span><br><span class="line">    // 校验 mode 和 block</span><br><span class="line">    if (!mode || !block) &#123;</span><br><span class="line">        if (mode) CFRelease(mode);</span><br><span class="line">        if (block) Block_release(block);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    // 链表节点创建，表尾添加</span><br><span class="line">    struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item));</span><br><span class="line">    new_item-&gt;_next = NULL;</span><br><span class="line">    new_item-&gt;_mode = mode;</span><br><span class="line">    new_item-&gt;_block = block;</span><br><span class="line">    if (!rl-&gt;_blocks_tail) &#123;</span><br><span class="line">        rl-&gt;_blocks_head = new_item;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rl-&gt;_blocks_tail-&gt;_next = new_item;</span><br><span class="line">    &#125;</span><br><span class="line">    rl-&gt;_blocks_tail = new_item;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="关联知识"><a href="#关联知识" class="headerlink" title="关联知识"></a>关联知识</h1><h2 id="Toll-Free-Bridging"><a href="#Toll-Free-Bridging" class="headerlink" title="Toll-Free Bridging"></a>Toll-Free Bridging</h2><ul><li>Toll-Free Bridging 是指在多个框架中数据类型可以无缝切换。在 iOS 中是指 CoreFoundation 和 Foundation 两个框架之间数据类型的转换。</li><li>不是所有者两个框架中的数据类型都可以相互转换。以下是不能相互转换的<ul><li>NSRunLoop 和 CFRunLoop </li><li>NSBundle 和 CFBundle</li><li>NSDateFormatter 和 CFDateFormatter</li></ul></li><li>MRC 下不涉及内存管理的转移，可以直接转换。</li><li>ARC 下涉及内存管理的转移，在转换时需要指定内存管理的所有权。<ul><li>__bridge: 不改变内存管理方式。<ul><li>CF -&gt; F: F 的内存由编译器管理，CF 的内存管理由开发者管理。</li><li>F -&gt; CF: F 的内存由编译器管理，CF 没有被 retain，不需要处理。</li></ul></li><li><strong>bridge_reatained: 解决 </strong>bridge 下 F -&gt; CF 时，F 被释放，CF 也就被释放，再使用就会出现内存泄露的问题。<ul><li>F 的内存有编译器管理，CF 会被编译器 retain，内存需要由开发者管理。</li><li>由于 CF 被 retain，再使用就不会出现 __bridge 无法解决的内存泄漏问题了。</li></ul></li><li><strong>bridge_transfer: 解决 </strong>bridge 下 CF -&gt; F 时，复杂的中间变量和 CF 的内存管理问题而做的简化处理。<ul><li>F 的内存由编译器管理</li><li>CF 的内存由编译器转移了，开发者不需要再处理。</li></ul></li></ul></li></ul><h2 id="进程-线程间通信"><a href="#进程-线程间通信" class="headerlink" title="进程/线程间通信"></a>进程/线程间通信</h2><ul><li>线程间使用 NSPort 通信 </li><li>进程间使用 NSTask 通信</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li>多个线程在临界区产生竞态条件，即会引起线程安全问题。</li><li>多发生在写操作时产生线程安全问题。</li><li>容易引起线程安全问题的资源：<ul><li>共享资源</li><li>局部对象引用：对象放在共享堆中，可以被多个线程使用，引用是不被共享的。<code>局部变量不会引起线程安全问题，因为存放在线程的栈中。</code></li><li>文件、数据库</li></ul></li><li>通过加锁来解决线程安全问题。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码</a></li><li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">关于RunLoop部分源码的注释</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li><li><a href="http://blog.gocy.tech/2016/09/03/runloop-source-reading/" target="_blank" rel="noopener">RunLoop学习笔记</a></li><li><a href="https://www.jianshu.com/p/ec629063390f" target="_blank" rel="noopener">老司机出品——源码解析之RunLoop详解</a></li><li><a href="https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork" target="_blank" rel="noopener">Check_For_Fork</a></li><li><a href="https://www.jianshu.com/p/c53f2eb116ae" target="_blank" rel="noopener">Toll-Free Bridging</a></li><li><a href="https://blog.csdn.net/yxh265/article/details/51483822" target="_blank" rel="noopener">iOS线程通信和进程通信的例子</a></li><li><a href="https://www.jianshu.com/p/4c50e04c82c7" target="_blank" rel="noopener">iOS-线程安全探究</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RunLoop </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开启我的博客</title>
      <link href="/2018/05/06/openMyBlog/"/>
      <url>/2018/05/06/openMyBlog/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h3><ol><li>node.js 安装</li><li>git 环境安装</li><li>hexo 安装 npm install -g hexo-cli 权限不够请使用 sudo npm install -g hexo-cli</li></ol><h3 id="GitHub-创建博客关联仓库"><a href="#GitHub-创建博客关联仓库" class="headerlink" title="GitHub 创建博客关联仓库"></a>GitHub 创建博客关联仓库</h3><ol><li>在gitHub上创建一个仓库，起名your_github_name.github.io</li></ol><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><ol><li><p>创建属于你的博客文件夹xxxBlog 并初始化</p><ul><li>cd xxxBlog</li><li>hexo init</li></ul></li><li><p>导入依赖包</p><ul><li>npm install</li></ul></li><li><p>在上述步骤生成的_config.yml中定制配置</p><ul><li>itle: Choose a title<br>subtitle: Any subtitle you like<br>description: Anything you like<br>author: Your name<br>language: zh-CN<br>timezone: Asia/Shanghai<br>deploy:<br>type: git<br>repo: <a href="https://github.com/your_github_name/your_github_name.github.com.git" target="_blank" rel="noopener">https://github.com/your_github_name/your_github_name.github.com.git</a><br>branch: master</li></ul></li></ol><h3 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h3><ol><li><p>开启本地验证</p><ul><li>hexo server</li></ul></li><li><p>安装部署器</p><ul><li>npm install hexo-deployer-git –save</li></ul></li><li><p>博客部署到GitHub上</p><ul><li>hexo deploy</li></ul></li><li><p>浏览器your_github_name.github.io访问部署以后的博客</p></li></ol><h3 id="博客主题切换"><a href="#博客主题切换" class="headerlink" title="博客主题切换"></a>博客主题切换</h3><ol><li><p>挑选自己喜欢的主题，Google上随便一搜hexo的主题多的是，我自己使用的是Maupassant的主题，屠夫的优化版。</p><ul><li>git clone <a href="https://github.com/tufu9441/maupassant-hexo.git" target="_blank" rel="noopener">https://github.com/tufu9441/maupassant-hexo.git</a> themes/maupassant</li></ul></li><li><p>安装主题和渲染器</p><ul><li>npm install hexo-renderer-jade –save</li><li>npm install hexo-renderer-sass –save</li></ul></li><li><p>重新编辑xxxBlog下的_config.yml文件</p><ul><li>将theme的值改为maupassant</li></ul></li><li><p>hexo三部曲</p><ul><li>hexo clean</li><li>hexo g</li><li>hexo deploy</li></ul></li><li><p>浏览器your_github_name.github.io访问部署以后的新主题的博客</p></li></ol><h3 id="404页面配置"><a href="#404页面配置" class="headerlink" title="404页面配置"></a>404页面配置</h3><ol><li>在source下创建一个404.html的文件</li><li>使用腾讯公益404代码，直接在html中写如下代码<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></li></ol><h3 id="适配多电脑发布博客"><a href="#适配多电脑发布博客" class="headerlink" title="适配多电脑发布博客"></a>适配多电脑发布博客</h3><ol><li>在github的your_github_name.github.io上创建一个分支，名hexo</li><li>将hexo设置为默认分支</li><li>git clone your_github_name.github.io 到本地，然后将xxxBlog里面的文件都拷贝到your_github_name.github.io中，将theme中的.git文件删除，git add/commit 这些变更。</li><li>以后只要git pull这个分支，然后npm install就可以在其他的电脑上操作你的博客了。</li></ol><h3 id="Hexo-的基本操作"><a href="#Hexo-的基本操作" class="headerlink" title="Hexo 的基本操作"></a>Hexo 的基本操作</h3><ol><li><p>创建新博客</p><ul><li>hexo new “create Blog”</li></ul></li><li><p>创建单独页面</p><ul><li>hexo new page xxx</li></ul></li><li><p>本地构建服务</p><ul><li>hexo server</li></ul></li><li><p>本地html缓存清理</p><ul><li>hexo clean</li></ul></li><li><p>html 生成</p><ul><li>hexo generate</li></ul></li><li><p>html 部署</p><ul><li>hexo deploy</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 博客基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
