<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一只进激的大白兔。"><title>RunLoop回顾总结之 Thread-Loop Store | (●—●)🐰Dash</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-118883756-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RunLoop回顾总结之 Thread-Loop Store</h1><a id="logo" href="/.">(●—●)🐰Dash</a><p class="description">(●—●)做人做事，赢在格局，输在计较！！！🐰</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RunLoop回顾总结之 Thread-Loop Store</h1><div class="post-meta">May 8, 2018<span> | </span><span class="category"><a href="/categories/RunLoop/">RunLoop</a> -> <a href="/categories/RunLoop/Design/">设计</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#撸代码看设计"><span class="toc-number">2.</span> <span class="toc-text">撸代码看设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop与线程之间的关系"><span class="toc-number">2.1.</span> <span class="toc-text">RunLoop与线程之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#核心代码"><span class="toc-number">2.1.1.</span> <span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助函数-TLS-操作函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">辅助函数 - TLS 操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流程图"><span class="toc-number">2.1.3.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">2.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未完，待续…"><span class="toc-number">2.2.</span> <span class="toc-text">未完，待续…</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用"><span class="toc-number">3.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function eventLoop() &#123;</span><br><span class="line">    initialize(); // 内部初始化</span><br><span class="line">        do&#123;</span><br><span class="line">            let msg = getNextMsg(); // 获取下一个消息/事件</span><br><span class="line">            processMsg(msg); // 执行消息/事件</span><br><span class="line">        &#125; while (msg != quit); // 循环知道退出消息到达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。</p>
<h1 id="撸代码看设计"><a href="#撸代码看设计" class="headerlink" title="撸代码看设计"></a>撸代码看设计</h1><h2 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h2><p>thread - runloop 是一对一 key-value 存储在进程中的全局Dict __CFRunLoops中。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:1353</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static pthread_t kNilPthreadT = (pthread_t)0; // 初始化  kNilPthreadT 为空线程</span><br><span class="line">static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。</span><br><span class="line">static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。</span><br><span class="line"></span><br><span class="line">// 获取 runnLoop 的函数。</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125; // 入参线程为空，则默认使用主线程。</span><br><span class="line"></span><br><span class="line">    __CFLock(&amp;loopsLock); // 操作 loops 前加锁。</span><br><span class="line"></span><br><span class="line">    if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">    </span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。</span><br><span class="line">        // 将 dict 赋值给 loops，内部有锁。</span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; </span><br><span class="line">            CFRelease(dict); // 释放临时变量dict。</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 加锁。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop</span><br><span class="line">    __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line"></span><br><span class="line">    // loops 中没有线程 t 的 loop</span><br><span class="line">    if (!loop) &#123; </span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 解锁。</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。</span><br><span class="line">        // 二次校验 loops 中有没有线程 t 的 loop。</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。</span><br><span class="line">            loop = newLoop; // 赋值给 loop。</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">        CFRelease(newLoop); // 释放 newLoop。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop; // 返回线程 t 的 loop。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取主线程的 mainLoop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // 不存在，则获取主线程的 mainLoop。</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 loop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // TLS 中获取当前线程的 loop。</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    // 不存在，则获取当前线程的 loop。</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数-TLS-操作函数"><a href="#辅助函数-TLS-操作函数" class="headerlink" title="辅助函数 - TLS 操作函数"></a>辅助函数 - TLS 操作函数</h3><p><code>CFPlatform.c  line: 648</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 存储函数</span><br><span class="line">CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，报错</span><br><span class="line">        // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值</span><br><span class="line">    </span><br><span class="line">    table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值</span><br><span class="line">    table-&gt;destructors[slot] = destructor; // 存储析构器</span><br><span class="line">    </span><br><span class="line">    return oldVal; // 返回数据变更之前的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取函数</span><br><span class="line">CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，则报错</span><br><span class="line">        // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    uintptr_t *slots = (uintptr_t *)(table-&gt;data);</span><br><span class="line">    return (void *)slots[slot]; // 按 key 从 data 中获取值并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取 TLS 的 table</span><br><span class="line">static __CFTSDTable *__CFTSDGetTable() &#123;</span><br><span class="line">    // 获取 TLS 的 table</span><br><span class="line">    __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific();</span><br><span class="line">    // Make sure we&apos;re not setting data again after destruction.</span><br><span class="line">    if (table == CF_TSD_BAD_PTR) &#123; // 被析构了</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // Create table on demand</span><br><span class="line">    if (!table) &#123;</span><br><span class="line">        // This memory is freed in the finalize function</span><br><span class="line">        table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间</span><br><span class="line">        pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 </span><br><span class="line">        __CFTSDSetSpecific(table); // 存储 table</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return table; //返回 table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// table 获取函数</span><br><span class="line">static void *__CFTSDGetSpecific() &#123;</span><br><span class="line">    return _pthread_getspecific_direct(CF_TSD_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="../../../../images/runLoop/manageThreadLoop.png" alt="loop 创建流图"><br><img src="../../../../images/runLoop/getMainLoop.png" alt="mainLoop 获取流程"><br><img src="../../../../images/runLoop/getCurrentLoop.png" alt="currentLoop 获取流程"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。</li>
<li>主线程的 RunLoop 是默认创建的，其他的线程的 RunLoop 是用时创建，懒加载的。</li>
<li>线程的 RunLoop 并不是每次都是从全局字典中获取的。这样可以加快获取的过程，有利于性能的提升。<ul>
<li>主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。</li>
<li>其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。</li>
</ul>
</li>
</ul>
<h2 id="未完，待续…"><a href="#未完，待续…" class="headerlink" title="未完，待续…"></a>未完，待续…</h2><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></li>
<li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">https://blog.csdn.net/ssirreplaceable/article/details/53793456</a></li>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></li>
<li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">https://blog.csdn.net/ssirreplaceable/article/details/53793456</a></li>
<li><a href="https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork" target="_blank" rel="noopener">https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork</a></li>
</ul>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.jpg&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=http://github.com/kangzhenpeng&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2018/05/08/RunLoopReviewSummary-TLM/" data-id="cjh301drw000axhfyc5o312tb" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNUlEQVR42u3aQW7DMAwF0dz/0i7QVYE29nxSKSBqtAqSxtHTgiVFvl54Xd+LvPNzvfv0/lu//2bZkiFDxraM63aRTZBnvnvOu3f43mTIkHEO4z7I8oC7KnDzvcmQIUMGCYv3P0+2JUOGDBlrGcGjw42Sw5IhQ8bJDFLE8m+RI+CvF9fiMmTI2JDRD5Gfe/3B/oYMGTI2YVyl1QnBvNkQPE2GDBmjGWmxytM70rBMf+UhKMuQIWM0gw978dysNorBE1MZMmScw+DXWB1ep3xF42gyZMgYzUgbmbVrMr6VztHIkCHjHMaqfLNTmvJ25oufmQwZMrZl8CKzFmT5pRsP8XE6KEOGjEEMfgXGm46rituHfwwyZMgYzeAXXjyZq8VDcjRBgihDhoxBjHiIARe9/9MGkCFDxjmMNMCl1PRy/yNzbTJkyNiWcb/RzmBrP+zGIViGDBlDGWmilpaafUDx1lCGDBmDGLwlwLeVNi95wA2mRWTIkDGI0X9obcArGKQg4xcyZMgYzUjD7qqhsTQcy5Ah42TGVVrkIiy9vOMth4dhCxkyZIxj9ENhmjIWNxReycmQIWMSoxNqefKXFrFpqSxDhozZDL7ScpS3QmvHFANkyJCxOaNWstaGMMjR1BJNGTJknMAgiR1vc9aaCulF2x/tARkyZMgotQFIUOa/GGevMmTIOIzBR7VIWpkClqWGMmTI2JbRL2I7KSbf9ENqKEOGjKGMWt616rotLYyLABkyZOzK+ALuSx3zZWfz6QAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/RunLoop/">RunLoop</a><a href="/tags/Thread/">Thread</a></div><div class="post-nav"><a class="next" href="/2018/05/06/openMyBlog/">开启我的博客</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'kangzhenpeng',
  repo: 'https://github.com/kangzhenpeng/kangzhenpeng.github.io.git',
  oauth: {
    client_id: '07853b80e09b00865a0a',
    client_secret: 'bc5c6954bfb2fb884805e1e30984be2557dcf889',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/RunLoop/">RunLoop</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/RunLoop/Design/">设计</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">博客基础</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/RunLoopReviewSummary-TLM/">RunLoop回顾总结之 Thread-Loop Store</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/openMyBlog/">开启我的博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.sunnyxx.com/" title="孙源大神的Blog" target="_blank">孙源大神的Blog</a><ul></ul><a href="https://onevcat.com/" title="王巍大神的Blog" target="_blank">王巍大神的Blog</a><ul></ul><a href="https://blog.ibireme.com/" title="Garan no Dou" target="_blank">Garan no Dou</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">(●—●)🐰Dash.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>