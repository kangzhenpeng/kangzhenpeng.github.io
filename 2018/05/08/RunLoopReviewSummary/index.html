<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一只进激的大白兔。"><title>RunLoop 回顾总结 | (●—●)🐰Dash</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-118883756-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RunLoop 回顾总结</h1><a id="logo" href="/.">(●—●)🐰Dash</a><p class="description">(●—●)做人做事，赢在格局，输在计较！！！🐰</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RunLoop 回顾总结</h1><div class="post-meta">May 8, 2018<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a> -> <a href="/categories/iOS/RunLoop/">RunLoop</a> -> <a href="/categories/iOS/RunLoop/Design/">设计</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用"><span class="toc-number">2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#框架图"><span class="toc-number">3.</span> <span class="toc-text">框架图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码分析"><span class="toc-number">4.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Loop-Thread-Relation"><span class="toc-number">4.1.</span> <span class="toc-text">Loop - Thread Relation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流程图"><span class="toc-number">4.1.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心代码"><span class="toc-number">4.1.2.</span> <span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助代码"><span class="toc-number">4.1.3.</span> <span class="toc-text">辅助代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-操作函数"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">TLS 操作函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loop-Run"><span class="toc-number">4.2.</span> <span class="toc-text">Loop Run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流程图-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心代码-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助代码-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">辅助代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Loop-运行数据-push-pop-函数"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">Loop 运行数据 push/pop 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Observer-Timer-Source-操作函数"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">Observer/Timer/Source 操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-操作函数"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">Block 操作函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联知识"><span class="toc-number">5.</span> <span class="toc-text">关联知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Toll-Free-Bridging"><span class="toc-number">5.1.</span> <span class="toc-text">Toll-Free Bridging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-线程间通信"><span class="toc-number">5.2.</span> <span class="toc-text">进程/线程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-number">5.3.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一般来说线程在处理完任务后，就会结束。为了让线程可以持续接受任务并执行，就需要有一个循环来持续接受消息并处理。通常称这个循环为EventLoop，这种模式在大多数系统中是类似的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function eventLoop() &#123;</span><br><span class="line">    initialize(); // 内部初始化</span><br><span class="line">        do&#123;</span><br><span class="line">            let msg = getNextMsg(); // 获取下一个消息/事件</span><br><span class="line">            processMsg(msg); // 执行消息/事件</span><br><span class="line">        &#125; while (msg != quit); // 循环知道退出消息到达</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 是在 OSX/iOS中，苹果对EventLoop的一种实现。有NSRunLoop、CFRunLoop两种可用。其中NSRunLoop是对CFRunLoop的一种封装。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/RunLoopApply.png"><br></figure>

<h1 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h1><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/RunLoopStructureChart.png"><br></figure>

<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="Loop-Thread-Relation"><a href="#Loop-Thread-Relation" class="headerlink" title="Loop - Thread Relation"></a>Loop - Thread Relation</h2><ul>
<li>Thread 与 RunLoop 是一对一的，且存储在一个全局的字典中。</li>
<li>主线程的 RunLoop 是默认创建的，其他线程的 RunLoop 是用时创建，懒加载的。</li>
<li>线程的 RunLoop 并不是每次都是从全局字典中获取的，而是从全局或者 TLS 中获取。这样可以加快获取的过程，有利于性能的提升。<ul>
<li>主线程的 RunLoop 在第一次是从全局字典获取，之后直接使用全局变量 __main。</li>
<li>其他线程的 RunLoop 在第一次是从全局字典获取，之后直接从 TLS 中获取。</li>
</ul>
</li>
<li>CFRunLoop 中使用了锁来保证线程安全。NSRunLoop 是基于 CFRunLoop 封装的，没有设计线程安全。</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/ThreadLoopRelation.png"><br></figure>

<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:1353</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static pthread_t kNilPthreadT = (pthread_t)0; // 初始化  kNilPthreadT 为空线程</span><br><span class="line">static CFMutableDictionaryRef __CFRunLoops = NULL; // 声明全局的一个字典变量并初始化为空。</span><br><span class="line">static CFLock_t loopsLock = CFLockInit; // 声明一个全局的锁，用来对 loops 保证线程安全。</span><br><span class="line"></span><br><span class="line">// 获取 runnLoop 的函数。</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125; // 入参线程为空，则默认使用主线程。</span><br><span class="line"></span><br><span class="line">    __CFLock(&amp;loopsLock); // 操作 loops 前加锁。</span><br><span class="line"></span><br><span class="line">    if (!__CFRunLoops) &#123; // 判断全局字典 loops 是否存在。</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">    </span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 创建一个临时可变字典。</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 创建 mainLoop。</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); // 将 mainLoop 与 mainThread 对应存储在临时的可变字典中。</span><br><span class="line">        // 将 dict 赋值给 loops，内部有锁。</span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; </span><br><span class="line">            CFRelease(dict); // 释放临时变量dict。</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        CFRelease(mainLoop); // 释放mainLoop，因为已经在 dict retain 了。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 加锁。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 从 loops 中获取线程 t 的 loop</span><br><span class="line">    __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line"></span><br><span class="line">    // loops 中没有线程 t 的 loop</span><br><span class="line">    if (!loop) &#123; </span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t); // 创建线程 t 的 loop。</span><br><span class="line">        __CFLock(&amp;loopsLock); // 解锁。</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 再次从 loops 中获取线程 t 的 loop，减小碰撞几率。</span><br><span class="line">        // 二次校验 loops 中有没有线程 t 的 loop。</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); // 将创建的 newloop 存储在 loops 中。</span><br><span class="line">            loop = newLoop; // 赋值给 loop。</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock); // 解锁。</span><br><span class="line">        CFRelease(newLoop); // 释放 newLoop。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123; // 线程 t 是否是当前线程</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); // TLS(线程局部存储) 存储线程 t 的 loop，稍后会有详细代码展示。</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); // TLS 存储线程销毁和 loop 销毁，实现线程销毁的时候，loop 也销毁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop; // 返回线程 t 的 loop。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取主线程的 mainLoop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // 创建全局变量 _mian，方便在其他线程中获取主线程的 loop。</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // 不存在，则获取主线程的 mainLoop。</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 loop 函数</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 检查当前进程是否有 fork，有则退出。</span><br><span class="line">    // TLS 中获取当前线程的 loop。</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    // 不存在，则获取当前线程的 loop。</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="辅助代码"><a href="#辅助代码" class="headerlink" title="辅助代码"></a>辅助代码</h3><h4 id="TLS-操作函数"><a href="#TLS-操作函数" class="headerlink" title="TLS 操作函数"></a>TLS 操作函数</h4><p><code>CFPlatform.c  line: 648</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 存储函数</span><br><span class="line">CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，报错</span><br><span class="line">        // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void *oldVal = (void *)table-&gt;data[slot]; // 按 key 从 data 中获取之前的值</span><br><span class="line">    </span><br><span class="line">    table-&gt;data[slot] = (uintptr_t)newVal; // 存储新值</span><br><span class="line">    table-&gt;destructors[slot] = destructor; // 存储析构器</span><br><span class="line">    </span><br><span class="line">    return oldVal; // 返回数据变更之前的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取函数</span><br><span class="line">CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123;</span><br><span class="line">    if (slot &gt; CF_TSD_MAX_SLOTS) &#123; // 大于最大槽个数，则报错</span><br><span class="line">        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 TSL 中的 table</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; // table 不存在，则报错</span><br><span class="line">        // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.</span><br><span class="line">        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    uintptr_t *slots = (uintptr_t *)(table-&gt;data);</span><br><span class="line">    return (void *)slots[slot]; // 按 key 从 data 中获取值并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取 TLS 的 table</span><br><span class="line">static __CFTSDTable *__CFTSDGetTable() &#123;</span><br><span class="line">    // 获取 TLS 的 table</span><br><span class="line">    __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific();</span><br><span class="line">    // Make sure we&apos;re not setting data again after destruction.</span><br><span class="line">    if (table == CF_TSD_BAD_PTR) &#123; // 被析构了</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // Create table on demand</span><br><span class="line">    if (!table) &#123;</span><br><span class="line">        // This memory is freed in the finalize function</span><br><span class="line">        table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable)); // 申请 table 的内存空间</span><br><span class="line">        pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize); // 析构绑定 </span><br><span class="line">        __CFTSDSetSpecific(table); // 存储 table</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return table; //返回 table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// table 获取函数</span><br><span class="line">static void *__CFTSDGetSpecific() &#123;</span><br><span class="line">    return _pthread_getspecific_direct(CF_TSD_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Loop-Run"><a href="#Loop-Run" class="headerlink" title="Loop Run"></a>Loop Run</h2><ul>
<li>RunLoop 实质上是一个 do…While 的循环，通过 port trap 消息来执行。</li>
<li>RunLoop 有五种运行 mode，每个 mode 中有多个 modeItem。<ul>
<li>kCFRunLoopDefaultMode: 默认运行 mode。</li>
<li>UITrackingRunLoopMode: 界面追踪 mode，用户追踪 scrollView 的滑动。</li>
<li>UIInitializationRunLoopMode: 启动初始化 mode，只在该 mode 下运行一次。</li>
<li>GSEventReceiveRunLoopMode：系统内部事件的 mode。</li>
<li>kCFRunLoopCommonModes：一个集合，集合其他 mode。</li>
<li>ModeItem: Source/Timer/Observer 的统称，没有实际的数据结构。</li>
<li>CommonModes: 标记为 common 的 mode，这些 mode 的 modeItem 是相同的。可以使得 RunLoop 可以看似在多个 mode 下共同运行。</li>
<li>CommonModeItems: common mode 下运行的事件集合。</li>
</ul>
</li>
<li>事件类型：<ul>
<li>Timer: 与 NSTimer 是 Toll-Free Bridging 的，基于时间的触发源。多个 Timer 对应一个modeQueuePort。</li>
<li>Source0: 只有 block，没有 port，用户级事件。多个 source0 对应一个 wakeupPort，当 source0 被标记后，会通过 wakeupPort 唤醒执行。</li>
<li>Source1: 有 blok 和 port，系统级事件。</li>
<li>Observer: 对 loop 过程的一个监听。<ul>
<li>KCFRunLoopEntry: loop 进入。</li>
<li>KCFRunLoopBeforeTimers: 开始处理Timers。</li>
<li>KCFRunLoopBeforeSources: 开始处理Source。</li>
<li>KCFRunLoopBeforeWaiting: 开始休眠。</li>
<li>KCFRunLoopAfterWaiting: 结束休眠。</li>
<li>KCFRunLoopExit: loop 退出。</li>
</ul>
</li>
</ul>
</li>
<li>RunLoop 在处理完 source0 后多空转一次，是为了保证source0被确切的执行完毕。</li>
<li>RunLoop 只能在单一 Mode 下运行，切换 mode 后会保存之前 mode 的运行数据。新 mode 下运行结束后，并不会继续之前的 mode 下重新 run，但是会还原之前的运行数据。</li>
<li>RunLoop 的 block 是用单向链表存储的，在第一次运行完 block 的时候会变更为环形链表，便于后续 block 执行的查找。block 猜测是 dispatch 过来的。</li>
<li>perform…selector 最后对应的是一个定时器事件。</li>
</ul>
<h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><figure><br>    <img src="http://p8pq9azjn.bkt.clouddn.com/image/runloop/run.png"><br></figure>

<h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p><code>CFRunLoop.c line:2649</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">// mode 切换函数 </span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK(); // 进程检查</span><br><span class="line">    // 检查loop是否被析构</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl); // 加锁</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 查找对应 modeName 的 mode 且对 mode 加锁</span><br><span class="line">    // 判断 mode 是否有效</span><br><span class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        Boolean did = false;</span><br><span class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode); // mode 解锁</span><br><span class="line">        __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished; // 返回运行结果</span><br><span class="line">    &#125;</span><br><span class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); // 记录当前 mode 的运行数据，并将当前数据置位，准备给新的 mode 使用</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode; // 记录当前 mode</span><br><span class="line">    rl-&gt;_currentMode = currentMode; // 变更 loop 的 mode 为目标 mode</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished; // 初始化一个运行结果</span><br><span class="line">    </span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 发出 entry 通知</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 执行 run 函数</span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); // 发出 exit 通知</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopModeUnlock(currentMode); // mode 解锁</span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun); // 将记录的之前的 mode 的运行数据还原</span><br><span class="line">    rl-&gt;_currentMode = previousMode; // 将记录的之前的 mode 还原</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">    return result; // 返回目标 mode 的运行结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Run 函数，已经把架构指令集适配代码简化掉了</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time(); // 获取机器时间</span><br><span class="line">    </span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123; // 判断 loop 是够已经停止</span><br><span class="line">        __CFRunLoopUnsetStopped(rl); // 置位状态</span><br><span class="line">        return kCFRunLoopRunStopped; // 返回状态</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123; // 对应的 mode 是否已经停止</span><br><span class="line">        rlm-&gt;_stopped = false; // 置位状态</span><br><span class="line">        return kCFRunLoopRunStopped; // 返回状态</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL; // 给dispatch 初始化一个空端口</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); // 判断是否第一次配发到主线程</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); // 在主线程下，会给 dispatch 配置一个 port</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL; // 给 modeQueue 初始化一个空 port，查看全文代码，queue 里面只是存储了 timer</span><br><span class="line">    if (rlm-&gt;_queue) &#123; // queue 存在</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue); // 配置一个 port</span><br><span class="line">        if (!modeQueuePort) &#123; // 配置 port 失败，报错</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer = NULL; // 初始化一个空timer，用来做 loop 超时监测的</span><br><span class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); // 超时上下文内存初始化</span><br><span class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">        seconds = 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR = 0ULL; // 超时时间为0</span><br><span class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; // 判断是够在限制时间间隔之内</span><br><span class="line">        dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); // 根据线程分配队列</span><br><span class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 创建定时器</span><br><span class="line">        dispatch_retain(timeout_timer); // 增加引用计数</span><br><span class="line">        // 配置上下文</span><br><span class="line">        timeout_context-&gt;ds = timeout_timer; // 设置 timer</span><br><span class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); // 设置 loop</span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); // 设置时间</span><br><span class="line">        // 设置上下文</span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">        // 设置超时操作</span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        // 设置取消操作</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        // 设置超时定时器</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        // 启动定时器</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; // infinite timeout</span><br><span class="line">        seconds = 9999999999.0; </span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX; // 设置最大超时时间</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Boolean didDispatchPortLastTime = true; // 初始化 dispatch port 的标记</span><br><span class="line">    int32_t retVal = 0; // 运行结果初始化</span><br><span class="line">    // 进入主体事件循环</span><br><span class="line">    do &#123;</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = NULL;</span><br><span class="line">        uint8_t msg_buffer[3 * 1024]; // 初始化一个 msg 的缓冲</span><br><span class="line"></span><br><span class="line">        mach_msg_header_t *msg = NULL; // msg</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL; // 当前活动的 port，初始化为 null</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet; // 待监听的 port 的集合</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl); // 设置可唤醒状态</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知要处理 timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理要处理 sources, 这里是 source0</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm); // 执行 block，从代码上猜测应该是 dispatch 塞进的 block，使用双向链表保存</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); // 执行可以执行的 source0</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm); // 执行block</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); // source 被执行完 或者 loop 超时，需要再空转一圈，来保证 source0 被彻底执行完，因为 source0 不具备主动唤醒能力，只能被动执行</span><br><span class="line">        </span><br><span class="line">        // 第一次不会执行</span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; // 是否是 dispatch 的 port </span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer; // 缓冲中取 msg</span><br><span class="line">            // 监听 port 中消息</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">                goto handle_msg; // 跳转到消息执行体</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = false; // 置位</span><br><span class="line">        </span><br><span class="line">        // 通知即将要休眠</span><br><span class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl); // 设置 sleep 状态</span><br><span class="line">        // do not do any user callouts after this point (after notifying of sleeping)</span><br><span class="line">        </span><br><span class="line">        // Must push the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced.</span><br><span class="line">        </span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet); // 收敛所有的 port</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm); // 解锁 mode</span><br><span class="line">        __CFRunLoopUnlock(rl); // 解锁 loop</span><br><span class="line">        </span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent(); // 记录休眠开始时间点</span><br><span class="line">        </span><br><span class="line">        // 进入内部监听循环体，只要跳出该循环体，则代表 loop 被唤醒</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                // objc_clear_stack(0);</span><br><span class="line">                // &lt;rdar://problem/16393959&gt;</span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer)); // 清空缓冲区</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); // 监听 port 集合</span><br><span class="line">            </span><br><span class="line">            // 是否为 modeQueuePort，用来处理 timers </span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; </span><br><span class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br><span class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue)); // 遍历 modeQueue，判断是否有 timer 到时了</span><br><span class="line">                // 到时，则置位，且跳出内部循环体</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123; </span><br><span class="line">                    // Leave livePort as the queue port, and service timers below</span><br><span class="line">                    rlm-&gt;_timerFired = false; // 置位</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123; // 继续读取 msg</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 非 modeQueuePort 的 port msg 被捕获，则跳出内部循环体</span><br><span class="line">                // Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl); // 加锁 loop</span><br><span class="line">        __CFRunLoopModeLock(rlm); // 加锁 mode</span><br><span class="line">        </span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart)); // 记录自己的休眠时间</span><br><span class="line">        </span><br><span class="line">        // Must remove the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</span><br><span class="line">        // in there if this function returns.</span><br><span class="line">        </span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet); // 将 dispatchPort 从监听集合中移除</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，因为已经醒来了</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl); // 置位 sleep 标记</span><br><span class="line">        // 通知结束休眠</span><br><span class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); </span><br><span class="line">        </span><br><span class="line">        // 消息执行体</span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl); // 设置忽略唤醒，对应 handle_msg 之前的设置</span><br><span class="line">        </span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123; // 是否为空 port</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING(); // 标记自己被唤醒的原因是“啥事也没发生”，一种兜底方案吧</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; // 是否为唤醒 port </span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP(); // 被唤醒 port 唤醒</span><br><span class="line">            // do nothing on Mac OS</span><br><span class="line">        &#125;</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; // 是否为 modeQueuePort</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER(); // 标记为被 Timer 事件唤醒</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // 根据机器事件执行 timer，但为成功</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl); // 再次执行 timer </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (livePort == dispatchPort) &#123; // 是否为 dispatch 的 port</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH(); // 标记唤醒的原因是 dispatch</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // 解锁 mode</span><br><span class="line">            __CFRunLoopUnlock(rl); // 解锁 loop</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);f</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            __CFRunLoopLock(rl); // 加锁 loop</span><br><span class="line">            __CFRunLoopModeLock(rlm); // 加锁 mode</span><br><span class="line">            sourceHandledThisLoop = true;  // 标记执行了 source</span><br><span class="line">            didDispatchPortLastTime = true; // 标记 dispatch 的 port 换新被执行完</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE(); // 标记唤醒的原因是 source</span><br><span class="line">            </span><br><span class="line">            // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</span><br><span class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line">            </span><br><span class="line">            // Despite the name, this works for windows handles as well</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); // 获取对应 port 的 source1</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">                mach_msg_header_t *reply = NULL;</span><br><span class="line">                // 执行 source1</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                if (NULL != reply) &#123;</span><br><span class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm); // 执行 block</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource; // 处理完事件的运行结果</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut; // 超时运行结果</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl); // 置位</span><br><span class="line">            retVal = kCFRunLoopRunStopped; // 停止的运行结果</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123; </span><br><span class="line">            rlm-&gt;_stopped = false; // 置位</span><br><span class="line">            retVal = kCFRunLoopRunStopped; // 停止的运行结果</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; // mode 已经被执行完了</span><br><span class="line">            retVal = kCFRunLoopRunFinished; // 结束的运行结果</span><br><span class="line">        &#125;</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">        </span><br><span class="line">    &#125; while (0 == retVal); // 外层循环执行的条件判断</span><br><span class="line">    </span><br><span class="line">    // 释放超时定时器</span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="辅助代码-1"><a href="#辅助代码-1" class="headerlink" title="辅助代码"></a>辅助代码</h3><h4 id="Loop-运行数据-push-pop-函数"><a href="#Loop-运行数据-push-pop-函数" class="headerlink" title="Loop 运行数据 push/pop 函数"></a>Loop 运行数据 push/pop 函数</h4><p><code>CFRunLoop.c line:660</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// push 函数</span><br><span class="line">CF_INLINE volatile _per_run_data *__CFRunLoopPushPerRunData(CFRunLoopRef rl) &#123;</span><br><span class="line">    volatile _per_run_data *previous = rl-&gt;_perRunData; // 保存之前的运行数据</span><br><span class="line">    rl-&gt;_perRunData = (volatile _per_run_data *)CFAllocatorAllocate(kCFAllocatorSystemDefault, sizeof(_per_run_data), 0); // 重新创建一个运行数据</span><br><span class="line">    // 对运行数据做初始化置位</span><br><span class="line">    rl-&gt;_perRunData-&gt;a = 0x4346524C;</span><br><span class="line">    rl-&gt;_perRunData-&gt;b = 0x4346524C; // &apos;CFRL&apos;</span><br><span class="line">    rl-&gt;_perRunData-&gt;stopped = 0x00000000;</span><br><span class="line">    rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x00000000;</span><br><span class="line">    return previous; // 返回当前的运行数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pop 函数</span><br><span class="line">CF_INLINE void __CFRunLoopPopPerRunData(CFRunLoopRef rl, volatile _per_run_data *previous) &#123;</span><br><span class="line">    // 判断当前的运行数据是否存在</span><br><span class="line">    if (rl-&gt;_perRunData) CFAllocatorDeallocate(kCFAllocatorSystemDefault, (void *)rl-&gt;_perRunData // 存在，则销毁</span><br><span class="line">    rl-&gt;_perRunData = previous; // 切换运行数据为上一次的运行数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Observer-Timer-Source-操作函数"><a href="#Observer-Timer-Source-操作函数" class="headerlink" title="Observer/Timer/Source 操作函数"></a>Observer/Timer/Source 操作函数</h4><p>操作函数基本类似，这里以 observer 的操作为例做代码展开。<br><code>CFRunLoop.c line:1668</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">// 执行 Observer</span><br><span class="line">static void __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;	/* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    </span><br><span class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0; // observer 个数获取</span><br><span class="line">    if (cnt &lt; 1) return; // 没有则退出</span><br><span class="line">    </span><br><span class="line">    /* Fire the observers */</span><br><span class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);</span><br><span class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * sizeof(CFRunLoopObserverRef)); // 创建一个 observer 的集合</span><br><span class="line">    CFIndex obs_cnt = 0;</span><br><span class="line">    for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">        if (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</span><br><span class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo); // 将未被执行的有效的 observer 保存到 observer 的集合中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">    for (CFIndex idx = 0; idx &lt; obs_cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</span><br><span class="line">        __CFRunLoopObserverLock(rlo); // observer 加锁</span><br><span class="line">        if (__CFIsValid(rlo)) &#123;</span><br><span class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</span><br><span class="line">            __CFRunLoopObserverSetFiring(rlo); // 设置执行状态</span><br><span class="line">            __CFRunLoopObserverUnlock(rlo); // observer 解锁</span><br><span class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info); // 执行 observer</span><br><span class="line">            if (doInvalidate) &#123;</span><br><span class="line">                CFRunLoopObserverInvalidate(rlo); // 设置失效状态</span><br><span class="line">            &#125;</span><br><span class="line">            __CFRunLoopObserverUnsetFiring(rlo); // 清除执行状态</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            __CFRunLoopObserverUnlock(rlo); // observer 解锁</span><br><span class="line">        &#125;</span><br><span class="line">        CFRelease(rlo);</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    __CFRunLoopModeLock(rlm); // mode 加锁</span><br><span class="line">    </span><br><span class="line">    if (collectedObservers != buffer) free(collectedObservers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加 observer</span><br><span class="line">void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return; // loop 析构的时候退出</span><br><span class="line">    if (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) return; // observer 和 loop 校验 </span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123; // common 标记的 mode 的处理</span><br><span class="line">        // 获取 common 标记的 mode 的集合</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        // 获取 common 标记的 modeItem 的集合</span><br><span class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 observer 添加到 common 标记的 modeItem 的集合中</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rlo&#125;;</span><br><span class="line">            /* add new item to all common-modes */</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rlm = __CFRunLoopFindMode(rl, modeName, true); // 查询 mode</span><br><span class="line">        // observer 的集合校验，为空则创建</span><br><span class="line">        if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) &#123;</span><br><span class="line">            rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        // 查询 observer 是否已经存在，不存在，则添加</span><br><span class="line">        if (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) &#123;</span><br><span class="line">            Boolean inserted = false;</span><br><span class="line">            for (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) &#123;</span><br><span class="line">                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">                if (obs-&gt;_order &lt;= rlo-&gt;_order) &#123;</span><br><span class="line">                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);</span><br><span class="line">                    inserted = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 不存在，则添加</span><br><span class="line">            if (!inserted) &#123;</span><br><span class="line">                CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);</span><br><span class="line">            &#125;</span><br><span class="line">            rlm-&gt;_observerMask |= rlo-&gt;_activities;</span><br><span class="line">            __CFRunLoopObserverSchedule(rlo, rl, rlm); // 对 observer 中的记录的 loop count 做变更</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除 observer</span><br><span class="line">void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 进程 fork 校验</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    __CFRunLoopLock(rl); // loop 加锁</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123; // 是否为 common 标记的 mode </span><br><span class="line">        // common 标记的 mode 集合中是否存在目标 observer</span><br><span class="line">        if (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rlo)) &#123;</span><br><span class="line">            CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">            CFSetRemoveValue(rl-&gt;_commonModeItems, rlo); // 从 common 标记的 modeItem 的集合中移除目标 observer</span><br><span class="line">            if (NULL != set) &#123;</span><br><span class="line">                CFTypeRef context[2] = &#123;rl, rlo&#125;;</span><br><span class="line">                /* remove new item from all common-modes */</span><br><span class="line">                CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (void *)context);</span><br><span class="line">                CFRelease(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rlm = __CFRunLoopFindMode(rl, modeName, false); // 查询 mode</span><br><span class="line">        // observer 集合校验</span><br><span class="line">        if (NULL != rlm &amp;&amp; NULL != rlm-&gt;_observers) &#123;</span><br><span class="line">            CFRetain(rlo);</span><br><span class="line">            CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo); // 查找 observer </span><br><span class="line">            if (kCFNotFound != idx) &#123;</span><br><span class="line">                CFArrayRemoveValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">                __CFRunLoopObserverCancel(rlo, rl, rlm); // 变更 observer 中记录的 loop count </span><br><span class="line">            &#125;</span><br><span class="line">            CFRelease(rlo);</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm); // mode 解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl); // loop 解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Block-操作函数"><a href="#Block-操作函数" class="headerlink" title="Block 操作函数"></a>Block 操作函数</h4><p><code>CFRunLoop.c line:1618</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// 执行 block 函数</span><br><span class="line">static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; // Call with rl and rlm locked</span><br><span class="line">    // blocks 链表校验</span><br><span class="line">    if (!rl-&gt;_blocks_head) return false;</span><br><span class="line">    // mode 校验</span><br><span class="line">    if (!rlm || !rlm-&gt;_name) return false;</span><br><span class="line">    Boolean did = false;</span><br><span class="line">    // 获取链表的表头</span><br><span class="line">    struct _block_item *head = rl-&gt;_blocks_head;</span><br><span class="line">    // 获取链表的表尾</span><br><span class="line">    struct _block_item *tail = rl-&gt;_blocks_tail;</span><br><span class="line">    rl-&gt;_blocks_head = NULL;</span><br><span class="line">    rl-&gt;_blocks_tail = NULL;</span><br><span class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</span><br><span class="line">    CFStringRef curMode = rlm-&gt;_name;</span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    struct _block_item *prev = NULL;</span><br><span class="line">    struct _block_item *item = head; // 从头开始遍历</span><br><span class="line">    while (item) &#123;</span><br><span class="line">        struct _block_item *curr = item;</span><br><span class="line">        item = item-&gt;_next;</span><br><span class="line">        Boolean doit = false;</span><br><span class="line">        // 校验是否执行</span><br><span class="line">        if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">            doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125;</span><br><span class="line">        // 不执行，则还原</span><br><span class="line">        if (!doit) prev = curr;</span><br><span class="line">        // 执行，则继续向后遍历</span><br><span class="line">        if (doit) &#123;</span><br><span class="line">            // 变更链表的头尾</span><br><span class="line">            if (prev) prev-&gt;_next = item;</span><br><span class="line">            if (curr == head) head = item;</span><br><span class="line">            if (curr == tail) tail = prev;</span><br><span class="line">            void (^block)(void) = curr-&gt;_block;</span><br><span class="line">            CFRelease(curr-&gt;_mode);</span><br><span class="line">            free(curr);</span><br><span class="line">            // 执行 block</span><br><span class="line">            if (doit) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">                did = true;</span><br><span class="line">            &#125;</span><br><span class="line">            Block_release(block); // do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    // 环形链表变更</span><br><span class="line">    if (head) &#123;</span><br><span class="line">        tail-&gt;_next = rl-&gt;_blocks_head;</span><br><span class="line">        rl-&gt;_blocks_head = head;</span><br><span class="line">        if (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    return did;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// block 存储函数</span><br><span class="line">void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    // mode 类型的判断</span><br><span class="line">    if (CFStringGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure mode exists</span><br><span class="line">        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true); // 查询 mode，没有则创建</span><br><span class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">    &#125; else if (CFArrayGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);</span><br><span class="line">        const void **values = (const void **)malloc(sizeof(const void *) * cnt);</span><br><span class="line">        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);</span><br><span class="line">        mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure modes exist</span><br><span class="line">        for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</span><br><span class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        free(values);</span><br><span class="line">    &#125; else if (CFSetGetTypeID() == CFGetTypeID(mode)) &#123;</span><br><span class="line">        CFIndex cnt = CFSetGetCount((CFSetRef)mode);</span><br><span class="line">        const void **values = (const void **)malloc(sizeof(const void *) * cnt);</span><br><span class="line">        CFSetGetValues((CFSetRef)mode, values);</span><br><span class="line">        mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        // ensure modes exist</span><br><span class="line">        for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);</span><br><span class="line">            if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        free(values);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mode = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    block = Block_copy(block);</span><br><span class="line">    // 校验 mode 和 block</span><br><span class="line">    if (!mode || !block) &#123;</span><br><span class="line">        if (mode) CFRelease(mode);</span><br><span class="line">        if (block) Block_release(block);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    // 链表节点创建，表尾添加</span><br><span class="line">    struct _block_item *new_item = (struct _block_item *)malloc(sizeof(struct _block_item));</span><br><span class="line">    new_item-&gt;_next = NULL;</span><br><span class="line">    new_item-&gt;_mode = mode;</span><br><span class="line">    new_item-&gt;_block = block;</span><br><span class="line">    if (!rl-&gt;_blocks_tail) &#123;</span><br><span class="line">        rl-&gt;_blocks_head = new_item;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rl-&gt;_blocks_tail-&gt;_next = new_item;</span><br><span class="line">    &#125;</span><br><span class="line">    rl-&gt;_blocks_tail = new_item;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="关联知识"><a href="#关联知识" class="headerlink" title="关联知识"></a>关联知识</h1><h2 id="Toll-Free-Bridging"><a href="#Toll-Free-Bridging" class="headerlink" title="Toll-Free Bridging"></a>Toll-Free Bridging</h2><ul>
<li>Toll-Free Bridging 是指在多个框架中数据类型可以无缝切换。在 iOS 中是指 CoreFoundation 和 Foundation 两个框架之间数据类型的转换。</li>
<li>不是所有者两个框架中的数据类型都可以相互转换。以下是不能相互转换的<ul>
<li>NSRunLoop 和 CFRunLoop </li>
<li>NSBundle 和 CFBundle</li>
<li>NSDateFormatter 和 CFDateFormatter</li>
</ul>
</li>
<li>MRC 下不涉及内存管理的转移，可以直接转换。</li>
<li>ARC 下涉及内存管理的转移，在转换时需要指定内存管理的所有权。<ul>
<li>__bridge: 不改变内存管理方式。<ul>
<li>CF -&gt; F: F 的内存由编译器管理，CF 的内存管理由开发者管理。</li>
<li>F -&gt; CF: F 的内存由编译器管理，CF 没有被 retain，不需要处理。</li>
</ul>
</li>
<li><strong>bridge_reatained: 解决 </strong>bridge 下 F -&gt; CF 时，F 被释放，CF 也就被释放，再使用就会出现内存泄露的问题。<ul>
<li>F 的内存有编译器管理，CF 会被编译器 retain，内存需要由开发者管理。</li>
<li>由于 CF 被 retain，再使用就不会出现 __bridge 无法解决的内存泄漏问题了。</li>
</ul>
</li>
<li><strong>bridge_transfer: 解决 </strong>bridge 下 CF -&gt; F 时，复杂的中间变量和 CF 的内存管理问题而做的简化处理。<ul>
<li>F 的内存由编译器管理</li>
<li>CF 的内存由编译器转移了，开发者不需要再处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程-线程间通信"><a href="#进程-线程间通信" class="headerlink" title="进程/线程间通信"></a>进程/线程间通信</h2><ul>
<li>线程间使用 NSPort 通信 </li>
<li>进程间使用 NSTask 通信</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>多个线程在临界区产生竞态条件，即会引起线程安全问题。</li>
<li>多发生在写操作时产生线程安全问题。</li>
<li>容易引起线程安全问题的资源：<ul>
<li>共享资源</li>
<li>局部对象引用：对象放在共享堆中，可以被多个线程使用，引用是不被共享的。<code>局部变量不会引起线程安全问题，因为存放在线程的栈中。</code></li>
<li>文件、数据库</li>
</ul>
</li>
<li>通过加锁来解决线程安全问题。</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码</a></li>
<li><a href="https://blog.csdn.net/ssirreplaceable/article/details/53793456" target="_blank" rel="noopener">关于RunLoop部分源码的注释</a></li>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li>
<li><a href="http://blog.gocy.tech/2016/09/03/runloop-source-reading/" target="_blank" rel="noopener">RunLoop学习笔记</a></li>
<li><a href="https://www.jianshu.com/p/ec629063390f" target="_blank" rel="noopener">老司机出品——源码解析之RunLoop详解</a></li>
<li><a href="https://stackoverflow.com/questions/47260563/whats-the-meaning-of-check-for-fork" target="_blank" rel="noopener">Check_For_Fork</a></li>
<li><a href="https://www.jianshu.com/p/c53f2eb116ae" target="_blank" rel="noopener">Toll-Free Bridging</a></li>
<li><a href="https://blog.csdn.net/yxh265/article/details/51483822" target="_blank" rel="noopener">iOS线程通信和进程通信的例子</a></li>
<li><a href="https://www.jianshu.com/p/4c50e04c82c7" target="_blank" rel="noopener">iOS-线程安全探究</a></li>
</ul>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.jpg&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=http://github.com/kangzhenpeng&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2018/05/08/RunLoopReviewSummary/" data-id="cjhhqzhje000r0vf32sb5gdzn" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNUlEQVR42u3a207DQAxF0f7/TweJ1zCTfey0os6epwrStCtIxrfXC5/j96xen8/+yvNvV9fcfGTIkPG1jGN7+tesvjR/1/4aGTJkPIdBguzqFmkY7QTl5c9lyJAhoxQE9ySeUMqQIUNGn5EG6No9ZciQIaNTgvJHsE8BP1SLy5Ah4wsZ/cHA+15/dL4hQ4aMf8k4wsODJg/NaZH8x7eSIUPGaEatgNxHPD6w5Ei0kCFDhozRDJJr1W7KFylua7rJkCFjHIN/AG+x8UWKdMy5LHdlyJAxmnHXakX6IGpBGQViGTJkjGN0mmv9EMyT0YsHJEOGjNEMnpzxwFpbpEgHnMu/iQwZMkYz0lwyLYDTIjZdAZEhQ8ZsBg9w6boYX9EgX5GksDJkyJjH6KxW8CL2fWMAGTJkPI1Ra8DdFYKDYvV8NxkyZDyAEcw5G8GUvIs36dAIU4YMGYMYZA2i1phLh6P8sy4mGzJkyBjHqBWQvNBNE8000MuQIWM2o1aUpkGWJ4vpA72Yb8iQIWMEg69K8LCYpom19FSGDBnPZPBkjlzffwRBKStDhozRjH6jP1326hwUpmXIkDGOcYSHp4AkNPMgexGyZciQMZrRb/Tzm3YacLURggwZMiYx+ApF2ixLEz4+WkCZowwZMsYx0gbZ/l28VZf+B4h33GTIkPEwRmc80C+PZciQISNltNYjSve/uF6GDBkPYNQWLFI2b9XFJbQMGTJGM2qDgfctVdRSTxkyZAxl/AC1llvRMxxyfAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/RunLoop/">RunLoop</a><a href="/tags/Thread/">Thread</a></div><div class="post-nav"><a class="pre" href="/2018/05/15/RunLoop-AutoreleasePool/">AutoreleasePool 回顾总结</a><a class="next" href="/2018/05/06/openMyBlog/">开启我的博客</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  id: 'cjhhqzhje000r0vf32sb5gdzn',
  owner: 'kangzhenpeng',
  repo: 'kangzhenpeng.github.io',
  oauth: {
    client_id: '07853b80e09b00865a0a',
    client_secret: 'bc5c6954bfb2fb884805e1e30984be2557dcf889',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/RunLoop/">RunLoop</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/RunLoop/Apply/">应用</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/RunLoop/Design/">设计</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">博客基础</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/autorelease/" style="font-size: 15px;">autorelease</a> <a href="/tags/autoreleasePool/" style="font-size: 15px;">autoreleasePool</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a> <a href="/tags/CADisplayLink/" style="font-size: 15px;">CADisplayLink</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/iOS-RunLoop-Apply-CADisplayLink/">CADisplayLink 回顾总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/15/RunLoop-AutoreleasePool/">AutoreleasePool 回顾总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/RunLoopReviewSummary/">RunLoop 回顾总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/openMyBlog/">开启我的博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.sunnyxx.com/" title="孙源大神的Blog" target="_blank">孙源大神的Blog</a><ul></ul><a href="https://onevcat.com/" title="王巍大神的Blog" target="_blank">王巍大神的Blog</a><ul></ul><a href="https://blog.ibireme.com/" title="Garan no Dou" target="_blank">Garan no Dou</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">(●—●)🐰Dash.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>